{"meta":{"title":"LuckyLight's blog","subtitle":"","description":null,"author":"LuckyLight","url":"http://blog.luckylight6.com","root":"/"},"pages":[{"title":"分类","date":"2019-03-03T11:18:26.392Z","updated":"2019-03-03T11:18:26.392Z","comments":false,"path":"categories/index.html","permalink":"http://blog.luckylight6.com/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-03-03T11:18:22.292Z","updated":"2019-03-03T11:18:22.292Z","comments":true,"path":"links/index.html","permalink":"http://blog.luckylight6.com/links/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-03-03T11:18:29.267Z","updated":"2019-03-03T11:18:29.267Z","comments":true,"path":"about/index.html","permalink":"http://blog.luckylight6.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-03T11:18:03.108Z","updated":"2019-03-03T11:18:03.108Z","comments":false,"path":"tags/index.html","permalink":"http://blog.luckylight6.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在 Hexo 中渲染数学公式","slug":"工具/在 Hexo 中渲染数学公式","date":"2019-03-11T16:00:00.000Z","updated":"2019-03-17T12:15:54.388Z","comments":true,"path":"2019/03/12/工具/在 Hexo 中渲染数学公式/","link":"","permalink":"http://blog.luckylight6.com/2019/03/12/工具/在 Hexo 中渲染数学公式/","excerpt":"","text":"在使用 Markdown 编写博客时，难免会遇到数学公式。虽然常见的 Markdown 编辑器都会集成 MathJax，用来渲染文档中的类 LaTex 格式编写的数学公式，但是在基于 Hexo 搭建的博客中，默认情况下渲染数学公式会存在各种各样的问题。 存在的问题 默认情况下， 如果想要在博客中渲染数学公式，只需要在文章开头的 Front-matter 中加入一行 mathjax: true 即可，十分简单，这样便可以渲染大部分的数学公式。 Hexo 默认使用的是 hexo-renderer-marked 引擎渲染网页，这个引擎会把一些特殊的 Markdown 符号转换为响应的 Html 标签，比如在 Markdown 语法中，下划线 _ 代表的是斜体，会被渲染引擎处理成 &lt;em&gt; 标签。而在类 LaTex 格式编写的数学公式中，下划线 _ 表示下标。这样的话，如果在数学公式中包含下标的情况下，渲染结果就会出错。比如，$x_i$ 在渲染的时候，会被处理为 $x&lt;em&gt;i&lt;/em&gt;$，这样 MathJax 引擎就认为该公式有语法错误，便不会再渲染。 解决方法 解决方法其实有很多种，在这里我只说一种最方便快捷且有效的方法，那便是更换 Hexo 的渲染引擎。具体的步骤大概是卸载掉原来的渲染器，安装一个针对 KeTeX 优化过的渲染器。 卸载 Hexo 默认渲染器 打开命令行窗口，切换路径到 Hexo 博客根目录，然后执行下面的命令。 1npm uninstall hexo-renderer-marked --save 安装大神优化过的渲染器 继续执行下面的命令。 1npm install hexo-renderer-markdown-it-plus --save 配置渲染器 配置渲染器是一项相当简单的任务，只需要在 Hexo 博客根目录的 _config.yml 配置文件中加入以下配置即可。 12345678910111213markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ plugins: - plugin: name: markdown-it-mark enable: false 配置 KaTeX 插件 默认情况下 KaTeX 插件是开启的状态。但是，单独使用此插件并不能立即在您的网站上正确显示数学公式。因此，如果你想使用 KaTeX 插件渲染数学公式，还需要添加 css 样式文件到你的网站。 以我的博客为例，我使用的是 Material X 主题，因此只要博客根目录下的 /themes/material-x/layout/_partial/head.ejs 中引入了一个 css 样式文件即可。 1&lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css\" rel=\"stylesheet\"&gt; 至此，你就可以在 Hexo 中使用 KaTeX 渲染数学公式了。","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.luckylight6.com/categories/工具/"}],"tags":[{"name":"MathJax","slug":"MathJax","permalink":"http://blog.luckylight6.com/tags/MathJax/"},{"name":"KaTeX","slug":"KaTeX","permalink":"http://blog.luckylight6.com/tags/KaTeX/"}]},{"title":"记一次神奇的 JSON 反序列化异常","slug":"记录/记一次神奇的 JSON 解析异常","date":"2019-03-02T16:00:00.000Z","updated":"2019-03-17T12:15:54.387Z","comments":true,"path":"2019/03/03/记录/记一次神奇的 JSON 解析异常/","link":"","permalink":"http://blog.luckylight6.com/2019/03/03/记录/记一次神奇的 JSON 解析异常/","excerpt":"","text":"背景 对于一个 Java 后端项目来说，JSON 反序列化是最常见不过的操作了，我们通常都会使用 fastjson、Jackson 或者 Gson 等 JSON 处理库来序列化或者反序列化 JSON，在我们的项目中也不例外。 初现 本来以为将一串 JSON 反序列化为一个实体是绝对不会出什么差错的，但天有不测风云，人有旦夕祸福，在项目发布新版本的第二天，CAT 就接连报警。 登录到生产环境的服务器查看日志后，发现其中出现了一些 JSON 反序列化失败的异常日志。 1com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual [, in field result 查找原因 从异常日志来看，可能是实体中的 result 字段定义的是一个对象，但是 JSON 中的 result 却是一个数组，因此将 JSON 反序列化成实体的时候就抛出了异常。 原因真的是这样吗？为了一探究竟，我从 Git 拉下了最新的代码，然后找到了发生错误的代码。 1return JSON.parseObject(json, Result.class); 其中，JSON.parseObject(String, Class) 方法是 fastjson 中将一串 JSON 反序列化为实体的方法。json 表示具体的 JSON 数据，其内容如下所示。 1234567891011121314&#123; \"status\": true, \"status\": \"\", \"message\": \"success\", \"result\": [&#123; \"name\": \"张三\", \"phone\": \"12345678910\", \"address\": \"上海上海市黄浦区\" &#125;, &#123; \"name\": \"李四\", \"phone\": \"01987654321\", \"address\": \"上海上海市青浦区\" &#125;]&#125; Result.class 表示将要反序列化的实体类的类型，其定义如下所示。 1234567891011@Datapublic class Result&lt;T&gt; &#123; private boolean status; private String statusCode; private String message; private T result;&#125; 为了重现这个问题，我在生产环境部署的 JAR 包中加入了测试方法，发布到生产环境运行，在不断的尝试后，我还是放弃了，尝试了无数次，这行代码都能够正常运行。 但是此时却出现了一个奇怪的现象，同事观察日志发现，在正常的业务代码中，这行代码有时候能够正常反序列化，有时候却会抛出异常。 这更加引起了我的好奇，这里的业务代码我们在此次版本中都没有做改动，为什么上一个版本没有任何问题？带着这个疑问，我在网上寻找原因。 经过不懈的努力，我终于在 fastjson 的 issues 中发现了一个类似的 issue，这个 issue 是 2016 年提出来的，在 issue 中有位同学说在 1.2.56 版本中，这个 bug 被修复了。同时，我也在一篇 博客 中找到了问题的原因。分析过程可以在这篇博客中查看，结论就是：fastjson 会缓存解析器，然后导致了在反序列化嵌套泛型的 JSON 时失败。 解决方案 在解析嵌套泛型的 JSON 数据时最好指定具体的泛型类型，像我的这个例子的代码可以改为如下所示。 1JSON.parseObject(json, new TypeReference&lt;Result&lt;List&lt;Order&gt;&gt;&gt;()&#123;&#125;);","categories":[{"name":"记录","slug":"记录","permalink":"http://blog.luckylight6.com/categories/记录/"}],"tags":[{"name":"fastjson","slug":"fastjson","permalink":"http://blog.luckylight6.com/tags/fastjson/"},{"name":"JSON","slug":"JSON","permalink":"http://blog.luckylight6.com/tags/JSON/"}]},{"title":"夯实 Java 基础 (3) - 进制","slug":"夯实 Java 基础/夯实 Java 基础 (3) - 进制","date":"2019-02-22T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2019/02/23/夯实 Java 基础/夯实 Java 基础 (3) - 进制/","link":"","permalink":"http://blog.luckylight6.com/2019/02/23/夯实 Java 基础/夯实 Java 基础 (3) - 进制/","excerpt":"","text":"什么是进制 计数的方法主要有两种，一种叫做带进位的计数方法，比如数学中的各种计算；还有一种叫做不带进位的计数方法，比如原始的结绳计数法，投票时常用的 “正” 字计数法。顾名思义，它们之间的区别就是一个带进位，一个不带进位。 我们平常所说的进制其实就是一种带进位的计数方法，是一种人为定义的带进位的计数方法。在古代，一斤等于十六两，每十六两为一斤，这就是十六进制。自然数是我们从小学就开始接触的东西，从零开始，逢十进一，这就是十进制。在计算机世界中，由于各种电子元器件只有高电平和低电平两种状态，因此使用二进制来进行各种运算。 位置记数法 943 这个数中有多少实体？也就是说，943 这个数表示多少件实物？用初中术语说，943 就是 9 个 100 加 4 个 10 加 3 个 1，或者说 是 900 个 1 加 40 个 1 加 3 个 1。那么，754 中又有多少实体？700 个 1 加 50 个 1 加 4 个 1。对吗？也许正确，答案是由你使用的记数系统的基数决定的。如果这些数字是以 10 为基数的，或者说是十进制数，也就是人们日常使用的数制，那么上述答案是正确的。但是在其他记数系统中，上述答案就错了。 记数系统的基数决定了这个系统中使用的数字。这些数字都是从 0 开始，到比基数小 1 的数字结束。例如，在以 2 为基数的系统中，有两个数字 0 和 1。在以 8 为基数的系统中，有 8 个数字，从 0 到 7。在以 10 为基数的系统中，有 10 个数字，从 0 到 9。基数决定了数位位置的含义。当给记数系统中的最后一个数字加 1 后，必须执行数位位置左移。 基数：记数系统的基本数值，规定了这个系统中使用的数字量和数位位置的值。 数字是用位置记数法编写的。最右边的数位表示它的值乘以基数的 0 次幂，紧挨着这个数位左边的数位表示它的值乘以基数的 1 次幂，接下来的数位表示它的值乘以基数的 2 次幂，再接下来的数位表示它的值乘以基数的 3 次幂，依次类推。也许你不知道自己对位置记数法如此熟悉。我们用它来计算 943 中的 1 的个数。 9×102=9×100=900​9 \\times 10^2 = 9 \\times 100 = 900​ 9×102=9×100=900​ 4×101=4×10=40​4 \\times 10^1 = 4 \\times 10 = 40​ 4×101=4×10=40​ 3×100=3×1=3​3 \\times 10^0 = 3 \\times 1 = 3​ 3×100=3×1=3​ 900+40+3=943​900 + 40 + 3 = 943​ 900+40+3=943​ 位值记数法：一种表达数字的系统，数位按顺序排列，每个数位有一个位值，数字的值是每个数位和位值的乘积之和。 位值记数法更正式的定义是用记数系统的基数的多项式表示的值。但什么是多项式呢？多项式是两个或多个代数项的和，每个代数项由一个常量乘以一个或多个变量的非负整数幂构成。在定义位置记数法时，变量指记数系统的基数。943 可以表示为下列多项式，其中 x​x​x​ 表示基数。 9×x2+4×x1+3×x0​9 \\times x^2 + 4 \\times x^1 + 3 \\times x^0​ 9×x2+4×x1+3×x0​ 更广泛地说，如果一个数字采用的是以 R​R​R​ 为基数的记数系统，且具有 n​n​n​ 个数位，那么可以用下列多项式表示它，其中 di​d_i​di​​ 表示数字中第 i​i​i​ 位的数值。 dn×Rn−1+dn−1×Rn−2+⋯+d2×R1+d1×R0d_n \\times R^{n-1} + d_{n-1} \\times R^{n-2} + \\dots + d_2 \\times R^1 + d_1 \\times R^0 dn​×Rn−1+dn−1​×Rn−2+⋯+d2​×R1+d1​×R0 二进制、八进制和十六进制 二进制 二进制是计算机世界的基础，想要了解计算机，必须先理解二进制。二进制由 “0” 和 “1” 两个数字表示，由 18 世纪德国数理哲学大师莱布尼兹发现，二进制数的运算规律是逢二进一。为区别于其它进制，二进制数的书写通常在数的右下方注上基数 2，或加后面加 B 表示，其中 B 是英文二进制 Binary 的首字母。比如，二进制数字 00000110 可以写成 (00000110)2(00000110)_2(00000110)2​ 或者 00000110B00000110B00000110B。 二进制的四则运算 加 二进制的加法有四种情况，其中，0 进位为 1。 0+0=00 + 0 = 0 0+0=0 0+1=10 + 1 = 1 0+1=1 1+0=11 + 0 = 1 1+0=1 1+1=101 + 1 = 10 1+1=10 减 二进制的减法也有四种情况。 0－0=00－0 = 0 0－0=0 1－0=11－0 = 1 1－0=1 1－1=01－1 = 0 1－1=0 0－1=10－1 = 1 0－1=1 乘 二进制的乘法同样有四种情况。 0×0=00 \\times 0 = 0 0×0=0 1×0=01 \\times 0 = 0 1×0=0 0×1=00 \\times 1 = 0 0×1=0 1×1=1​1 \\times 1 = 1​ 1×1=1​ 除 二进制的除法只有两种情况，因为正常情况下除数为 0 是不允许的。 0÷1=00 \\div 1 = 0 0÷1=0 1÷1=11 \\div 1 = 1 1÷1=1","categories":[{"name":"夯实 Java 基础","slug":"夯实-Java-基础","permalink":"http://blog.luckylight6.com/categories/夯实-Java-基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"夯实 Java 基础 (2) - 计算机系统简介","slug":"夯实 Java 基础/夯实 Java 基础 (2) - 计算机系统简介","date":"2019-02-19T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2019/02/20/夯实 Java 基础/夯实 Java 基础 (2) - 计算机系统简介/","link":"","permalink":"http://blog.luckylight6.com/2019/02/20/夯实 Java 基础/夯实 Java 基础 (2) - 计算机系统简介/","excerpt":"","text":"计算机系统就像一个交响乐团，把许多不同的元素组织在一起，构成了一个整体，但这个整体的功能却远远大于各个部件的功能总和。 计算机系统 计算机是一种设备，而计算机系统则是一种动态实体，用于解决问题以及与它所处的环境进行交互。计算机系统由软件、硬件和它们管理的数据构成。 计算机硬件是构成机器及其附件（包括机箱、电路板、芯片、电线、硬盘驱动器、键盘、显示器、打印机，等等）的物理元件集合。计算机软件是提供计算机执行的指令的程序集合。计算机的核心是它管理的数据。如果没有数据，硬件和软件都毫无作用。 计算机系统的分层 计算机系统就像一个洋葱，由许多层构成。每个分层在整个系统设计中都扮演一个特定的角色。 最内层的信息层反映了在计算机上表示信息的方式，它是一个纯概念层。计算机上的信息采用二进制数字 1 和 0 管理。所以，要理解计算机处理技术，首先必须理解二进制数制以及它与其它数制（如人们日常使用的十进制数制）的关系。然后了解如何获取多种类型（如数字、文本、图像、音频和视频）的信息，以及如何用二进制格式表示它们。 硬件层由计算机系统的物理硬件组成。计算机硬件包括的设备有门和电路，它们都按照基本原理控制电流。正是这些核心电路，使专用的元件（如计算机的中央处理器 CPU 和存储器）得以运转。 程序设计层负责处理软件、用以实现计算的指令和以及管理数据。程序有多种形式，可以在许多层面上执行，由各种语言实现。尽管程序设计问题多种多样，但是它们的目的是相同的，即解决问题。 操作系统层用于管理计算机的资源。诸如 Windows、Linux 或 Mac OS 这样的操作系统可以使我们与计算机系统进行交互，管理硬件设备、程序和数据间的交互方式。了解操作系统为我们做了什么，通常是理解计算机的关键。 前面的分层重点在于使计算机系统运转，而应用程序层的重点则是用计算机解决真实世界的问题。 通信层使得计算机不再只是某个人桌面上的孤立系统，通过通信层，计算机被连接到网络上，以共享信息和资源。 抽象 上面分析的计算机系统的层次是抽象的一种例子。所谓抽象，其实是一种心理模型，是一种思考事情的方式，他删除它删除或隐藏了复杂的细节，只保留实现目标所必需的信息。 我们的日常生活中充满了抽象。例如，要把一辆车开到商店去，我们不需要知道车是如何运转的。也就是说，我们根本不必详细地知道引擎是如何工作的。你只需要知道一些基础知识，即如何与车互动以及如何操作刹车、油门和方向盘，甚至不必同时考虑这几个方面。 抽象是计算的关键，计算机系统的分层表现了抽象的概念。此外，抽象还以各种形式出现在各个分层中。 计算机的历史 计算机硬件的简史 辅助人们进行各种计算的设备自古就有，迄今为止，它们还在不断进化中。 早期历史 出现在公元前 16 世纪的算盘是一种记录数值的工具，人们可以用它进行基本的数学运算。 17 世纪中叶，法国数学家 Blaise Pascal 建造b并出售了一种齿轮驱动的机械机器，它可以执行整数的加法和减法运算。 17 世纪末，德国数学家 Gottfried Wilhelm von Leibniz 建造了第一台能够进行四种整数计算（加法、减法、乘法和除法）的机械设备。遗憾的是，当时的机械齿轮和操作杆的水平有限，使 Leibniz 机的结果不那么可信。 18 世纪晚期，Joseph Jacquard 发明了 Jacquard 织布机。这种织布机利用一套穿孔卡片来说明需要什么颜色的线，从而控制了纺织图案。尽管 Jacquard 织布机不是一种计算设备，但是它第一次使用了穿孔卡片这种输入方式。 计算机硬件的下一步重大发展直到 19 世纪才出现，这一次是由英国数学家 Charles Babbage 发明的，他称之为分析机。他的设计太过复杂，以至于当时的技术水平不能建造那样的机器，所以他的发明根本就没有实现。但是，在他构想的设计中，却包括许多现代计算机的重要部件。他的设计中第一次出现了内存，这使中间值不必再重新输入。此外，他的设计还包括数字输入和机械输入法，采用了与 Jacquard 织布机使用的穿孔卡片相同的方式。 Lovelace 伯爵夫人 Ada Augusta 是计算机历史上的传奇人物。Ada 是英国诗人 Lord Byron 的女儿，是一位接触的数学家。她对 Babbage 的分析机非常感兴趣，扩充了他的想法（同时修改了他的一些错误）。Ada 以第一位程序员著称。循环的概念（即一系列重复执行的指令）也归功于她。美国国防部广泛使用的 Ada 程序设计语言即是以她的名字命名的。 19 世纪晚期和 20 世纪初，计算机系统迅速发展起来。William Burroughs 制造并销售了一台机械加法机。Herman Hollerith 博士发明了第一台机电式制表机，从穿孔卡片读取信息。他的设备从根本上改变了美国每十年举行一次的人口普查。后来，Hollerith 博士创建了当今著名的 IBM 公司。 1936年，一种理论得以发展，本质上它与硬件毫无关系，但它对计算机科学产生了深远的影响。英国数学家 Alan M. Turing 发明了一种抽象数学模型图灵机，为计算机理论的主要领域奠定了基础。分析图灵机的功能是所有学习计算机科学的学生的理论学习的一部分。 到第二次世界大战爆发时，已经有几台计算机处于设计和建造中。Harvard Mark I 和 ENIAC 是当时最著名的两台机器。 1951年，美国人口普查局收到了第一台商业计算机 UNIVAC I。UNIVAC I 的出现结束了以算盘为开端的计算早期历史。 1951年后，计算机被越来越广泛地用来解决各个领域中的问题。 第一代（1951 ~ 1959） 第一代（大约从 1951 年到 1959 年）商用计算机使用真空管存储信息。它会大量生热，不是非常靠谱。此外，它们还需要巨大的专用房间。 第一代计算机的主存储器是在读/写臂下旋转的磁鼓。当被访问的存储单元旋转到读/写臂之下时，数据将被写入这个单元或从这个单元中读出。 输入设备是一台读卡机，可以阅读 IBM 卡（由 Hollerith 卡演化而来）上的孔。输出设备是穿孔卡片或行式打印机。在这一代将要结束时，出现了磁带驱动器，它比读卡机快得多。磁带是顺序存储设备，也就是说，必须按照线性顺序访问磁带上的数据。 计算机存储器外部的存储设备叫做辅助存储设备。磁带是一种辅助存储设备。输入设备、输出设备和辅助存储设备一起构成了外围设备。 第二代（1959 ~ 1965） 晶体管的出现标志着第二代商用计算机的诞生。晶体管代替真空管成了计算机硬件的主要部件。它比真空管更小、更可靠、更快、寿命更长也更便宜。 第二代计算机中还出现了即时存取存储器。访问磁鼓上的信息时，CPU 必须等待读/写臂旋转到正确的位置。第二代计算机使用磁芯作为存储器，这是一种微小的环形设备，每个磁芯可以存储一位信息。这些磁芯由电线排成一列，构成存储单元，存储单元组合在一起构成了存储单位。由于设备是静止不动的，而且是电力访问的，所以能够即时访问信息。 磁盘是一种新的辅助存储设备，也出现在第二代计算机中。磁盘比磁带快，因为使用数据项在磁盘上的位置就可以直接访问它。访问磁盘上的一个数据项时，必须先访问这个数据项之前的所有数据，而磁盘上的数据都有位置标识符，我们称之为地址。磁盘的读/写头可以被直接送到磁盘上存储所需的信息的特定位置。 第三代（1965 ~ 1971） 在第二代计算机中，晶体管和其他计算机元件都被手工集成在印刷电路板上。第三代计算机的特征是集成电路，一种具有晶体管和其他元件以及它们的连线的硅片。集成电路比印刷电路小，它更便宜、更快并且更可靠。Intel 公司的奠基人之一 Gordon Moore 注意到从发明集成电路起，一个集成电路板上能够容纳的电路的数量每年增长一倍，这就是著名的摩尔定律。 晶体管也被应用在存储器构造中。每个晶体管表示一位信息。集成电路技术允许用晶体管建造存储板。辅助存储设备仍然是必需的，因为晶体管存储器不稳定，也就是说，断电之后，所有的信息都将消失。 终端（带有键盘和屏幕的输人/输出设备）便是在这一代计算机中出现的。键盘使用户可以直接访问计算机，屏幕则可以提供立即响应。 第四代（1971 ~ ?） 大规模集成化是第四代计算机的特征。20 世纪 70 年代早期，一个硅片上可以集成几千个晶体管，而 80 年代中期，一个硅片则可以容纳整个微型计算机。主存储设备仍然依赖芯片技术。在过去的 40 年中，每一代计算机硬件的功能都变得越来越强大，体积越来越小，花费也越来越少。Moore 定律被改为芯片的集成度每 18 个月增长一倍。 并行计算 20 世纪 80 年代末，尽管使用单处理器的计算机仍然盛行，但是新的机器体系结构出现了。使用并行体系结构的计算机依靠的是一套互相连接的中央处理器。 一种并行机器的组织结构是所有所有处理器共享一个存储部件。另一种组织机构是每个中央处理器具有自己的本地内存，与其它处理器通过高速内部网进行通信。 并行体系结构提供了几种加快执行速度的方法。一种是把程序中的一步操作分成多个片段，在几个独立的处理器上同时执行这些代码片段，这种机器被称为 SIMD（单指令多数据流，single-instruction, multiple-data-stream）计算机。另一种可以同时运行程序的不同部分，这种机器被称为 MIMD（多指令多数据流，multiple-instruction, multiple-data-stream）计算机。 虽然把上百甚至上千个处理器组织在一台机器中有巨大的潜能，但是为这种计算机进行程序设计的难度也很高。并行计算机的软件设计不同于在一个计算机序列的软件设计。程序设计人员必须重新思考解决问题的方法，利用并行性进行程序设计。 连网 20 世纪 80 年代，多用户大型机的概念被小型机器连接成的网络替代，这些小型机器通过连网共享打印机、软件和数据这些资源。 1973 年由 Robert Metcalfe 和 David Boggs 发明的以太网是一种廉价的同轴电缆和一套能够让机器互相通信的协议。 1989 年，Novell Netware 用文件服务器把 PC 连接在一起。文件服务器是一台具有大容量的存储器以及强劲的输入/输出能力的 PC。把数据和办公自动化软件放在服务器上，而不是在每台 PC 上放置一个副本，这样既达到了集中管理的目的，又给予了每台 PC 自主权。把工作站或 PC 连接成网络，就形成了 LAN（局域网，local area network）。 Internet 是从 ARPANET 演化来的，ARPANET 是美国政府从 20 世纪 60 年代开始资助的网络，由 11 个节点构成，集中分布在 Los Angeles 和 Boston 地区。与 ARPANET 和 LAN 一样，Internet 使用包交换的方法共享信息。但是，Internet 由分布在世界各地的不同网络组成，这些网络之间采用通用的 TCP/IP（传输控制协议/网际协议，）协议通信。 计算机软件的简史 第一代软件（1951 ~ 1959） 第一代程序是用j机器语言编写的。所谓机器语言，即内置在计算机电路中的指令。即使是对两个数字求和这样的小任务也要动用 3 条二进制指令，程序设计人员必须记住每种二进制数字的组合表示什么。因此，使用机器语言进行程序设计不仅耗时，而且容易出错。 由于编写机器代码非常乏味，有些程序设计人员就开发了一些工具辅助程序设计。因此，第一代人工程序设计语言出现了。这些语言被称为汇编语言，它们使用助记忆码表示每条机器语言指令。 由于每个程序在计算机上执行时采用的z最终形式都是机器语言，所以汇编语言的开发者还创建了一种翻译程序，把用汇编语言编写的程序翻译成用机器语言编写的。一种被称为汇编器的程序将读取每条用助记忆码编写的程序指令，把它翻译成等价的机器语言。 汇编语言是程序设计人员和机器硬件之间的缓冲器。即使是现在，如果需要编写高效的代码， 那么还是会用汇编语言编写程序。 第二代软件（1959 ~ 1965） 当硬件变得更强大时，就需要更强大的工具能有效地使用它它们。当然，汇编语言是向正确的方向前进了一步，但是程序设计人员还是必须记住单独的机器指令。第二代软件一定要由更强大的语言开发。使用高级语言，程序设计人员就能够使用类似于英语的语句编写指令。 第二代软件时期开发的两种语言，目前仍在使用，它们是 FORTRAN（为数字应用程序设计的语言）和 COBOL（为商业应用程序设计的语言）。这一时期设计的另一种仍然在使用的语言是 Lisp，它主要用于人工智能的应用程序和研究。 第三代软件（1965 ~ 1971） 在第三代商用计算机时期，很显然，人们是计算机的处理速度放慢了。计算机在等待计算机准备下一个作业时，无所事事。解决方法是使所有计算机资源处于计算机的控制中，也就是说，要编写一种程序，决定何时运行什么程序。这种程序被称为操作系统。 在前两代软件时期，实用程序用于处理频繁执行的任务。装入器把程序载入内存，连接器则把大型程序连接在一起。第三代软件改进了这些实用程序，使它们处于操作系统的引导下。实用程序、操作系统和语言翻译程序（汇编器和编译器）构成了系统软件。 第四代软件（1971 ~ 1989） 20 世纪 70 年代出现了更好的程序设计技术——结构化程序设计方法，一种有逻辑、有规则的程序设计方法，著名的 C 语言就是在这一时期出现的。 更好、更强大的操作系统也被开发出来了。AT&amp;T 公司作为研究工具开发的 UNIX 系统成了许多大学的标准设置。为 IBM PC 开发的 PC-DOS 系统和为了兼容开发的 MS-DOS 系统都成了个人计算机的标准系统。Macintosh 机的操作系统引入了鼠标的概念和点击式的图形界面，因此彻底改变了人机交互方式。 第五代软件（1990 ~ 今天） 第五代中有三个著名事件，即在计算机软件业具有主导地位的 Microsoft 公司的崛起、面向对象的设计和编程方法的出现以及万维网（World Wide Web）的普及。","categories":[{"name":"夯实 Java 基础","slug":"夯实-Java-基础","permalink":"http://blog.luckylight6.com/categories/夯实-Java-基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"夯实 Java 基础 (1) - 前言","slug":"夯实 Java 基础/夯实 Java 基础 (1) - 前言","date":"2019-02-16T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2019/02/17/夯实 Java 基础/夯实 Java 基础 (1) - 前言/","link":"","permalink":"http://blog.luckylight6.com/2019/02/17/夯实 Java 基础/夯实 Java 基础 (1) - 前言/","excerpt":"","text":"距上一次写博客已经隔了很长一段时间了，重新拿出已经吃灰的键盘，主要是想复习一下 Java 基础。当然，不仅仅是 Java 基础，其中可能还会穿插一些计算机原理、网络基础、操作系统等等相关的知识。之后，也可能会阅读一下 JDK、Spring、MyBatis 等 Java 相关的源码，额~不好意思扯远了，这些都还有些遥远。 首要的目标还是复习 Java 基础知识，工作了一年左右发现基础还是非常重要的，就像我有的同事是从 .NET 转 Java 半路出家的，由于他们没有系统地学习过 Java，因此在日常开发中踩了很多坑。如果你的基础非常扎实的话，那么这些坑对你来说就如履平地。但是，基础扎实并非不用复习了，俗话说，温故而知新，随着能力的提升，在复习基础知识的时候，总会有新的收获。 这次主要是基于 JDK11 来复习 Java 基础，因此过程中也会描述一些 JDK8~JDK11 的新特性。像 JDK8 中的 Lambda 表达式、JDK9 中的模块系统、JDK10 的局部变量类型推断、JDK11 中对于集合和字符串 API 的增强……这些新特性我也会在之后的文章中一一解读。 本文只是作为前言存在，所以下面就简单的介绍一下 Java 语言的概况。 什么是 Java Java 是一门面向对象编程语言，不仅吸收了 C++ 语言的各种优点，还摒弃了 C++ 里难以理解的多继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。Java 语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。 Java 能做什么 Java 可以开发桌面软件 一般编程语言都可以做软件，Java 也不例外，像 IDEA、Eclipse、MyEclipse 等知名 Java 开发工具，都是用 Java 开发的。 Java 可以开发游戏 或者你不知道，在以前诺基亚还很流行的时候，你玩的手机游戏有 90% 以上都是 Java 开发的，当然现在已经很少人再去开发了，都转到安卓上去了。当然，PC 端也有 Java 开发的游戏，最经典的就是：《我的世界》(minecraft ，简称 MC)。 Java 可以开发 Android 应用 Java 可以算得上是 Android 的主流开发语言（目前 Google 官方在 推行 Kotlin），你的 Android 手机中的绝大部分应用都是使用 Java 开发的。 Java 可以开发网站 Java 最常见的用途就是开发网站了，像我们常见的网站（淘宝、天猫、京东……）的后端就是使用 Java 做为主要语言进行开发的。 Java 发展历史 1995 年 1 月 23 日，发布 JDK1.0 1997 年 2 月 19 日，发布 JDK1.1 1998 年 12 月 4 日，发布 JDK1.2 2000 年 5 月 8 日，发布 JDK1.3 2002 年 2 月 13 日，发布 JDK1.4 2004 年 9 月 30 日，发布 JDK5 2006 年 12 月 12 日，发布 JDK6 2011 年 7 月 28 日，发布 JDK7 2014 年 3 月 18 日，发布 JDK8 2017 年 9 月 21 日，发布 JDK9 2018 年 3 月 21 日，发布 JDK10 2018 年 9 月 25 日，发布 JDK11","categories":[{"name":"夯实 Java 基础","slug":"夯实-Java-基础","permalink":"http://blog.luckylight6.com/categories/夯实-Java-基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"夯实 Java 基础 (0) - 目录","slug":"夯实 Java 基础/夯实 Java 基础 (0) - 目录","date":"2019-02-09T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2019/02/10/夯实 Java 基础/夯实 Java 基础 (0) - 目录/","link":"","permalink":"http://blog.luckylight6.com/2019/02/10/夯实 Java 基础/夯实 Java 基础 (0) - 目录/","excerpt":"","text":"夯实 Java 基础 (1) - 前言 重点描述编写这个系列的目的。 夯实 Java 基础 (2) - 计算机系统简介 主要介绍计算机系统的分层，以及计算机硬件和软件的发展历史。计算机中字符的表示方式等。 夯实 Java 基础 (3) - 进制 主要介绍进制以及进制之间的相互转换。 夯实 Java 基础 (4) - Java 简介 简要介绍 Java 语言和 Java 平台，说明 Java 的应用范围、主要特性和优缺点。 夯实 Java 基础 (5) - JDK 的安装 简要介绍什么是 JDK、JRE 和 JVM。 简述 JDK、JRE 和 JVM 之间是什么关系。 详细介绍 JDK 在各个平台下（Windows、Linux 以及 MacOS）的安装。 夯实 Java 基础 (6) - Java 开发常用的 IDE 从简单的记事本，到功能较为完善的多功能编辑器，再到功能完善的 IDE（集成开发环境），每种编辑器都有着不同的使用方式。本文主要介绍常用编辑器（记事本、VS Code 以及 IDEA）的使用。","categories":[{"name":"夯实 Java 基础","slug":"夯实-Java-基础","permalink":"http://blog.luckylight6.com/categories/夯实-Java-基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"Spring Boot 2.0 新特性","slug":"Spring Boot/Spring Boot 2.0 新特性","date":"2018-08-08T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2018/08/09/Spring Boot/Spring Boot 2.0 新特性/","link":"","permalink":"http://blog.luckylight6.com/2018/08/09/Spring Boot/Spring Boot 2.0 新特性/","excerpt":"","text":"编程语言 Java 8+、Kotlin 底层框架 Spring Framework 5.0.X 全新特性 Web Flux（新型的声明式的函数式编程） 为什么选择 Web Flux？ 函数编程：Java 8 Lambda 响应编程：Reactive Streams 异步编程：Servlet 3.1 或 Asyc NIO","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.luckylight6.com/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.luckylight6.com/tags/Spring-Boot/"}]},{"title":"初识 Spring Boot","slug":"Spring Boot/初始 Spring Boot","date":"2018-01-08T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2018/01/09/Spring Boot/初始 Spring Boot/","link":"","permalink":"http://blog.luckylight6.com/2018/01/09/Spring Boot/初始 Spring Boot/","excerpt":"","text":"简介 Spring Boot 是一个全新的框架，其设计目的是用来简化 Spring 应用的初始搭建以及开发过程。Spring Boot 为Spring 平台及第三方库提供开箱即用的设置，这样开发人员就不再需要各种各样的配置，因此大多数 Spring Boot 应用不需要或者只需要很少的 Spring 配置。 特点 创建独立的 Spring 应用程序 嵌入的 Tomcat，无需部署 WAR 文件 简化 Maven 配置 自动配置 Spring 绝对没有代码生成和对 XML 没有要求配置 系统要求 默认情况下，Spring Boot 1.5.9.RELEASE 版本要求使用 Java 7 和 Spring Framework 4.3.13.RELEASE 或者它们的更高版本。 注：尽管你可以在 Java 6 或 Java 7 环境下使用 Spring Boot，通常建议尽可能使用 Java 8。 安装 Spring Boot 可以跟经典的 Java IDE（Eclipse，IntelliJ 等）一起使用或安装成一个命令行工具。不管怎样，你都需要安装 JDK 1.6 或更高版本。在开始之前，你需要检查下当前安装的 Java 版本： 1java -version 引入 JAR 文件安装 对于 Java 开发者来说，使用 Spring Boot 就跟使用其他 Java 库一样，只需要在你的 classpath 下引入适当的 spring-boot-*.jar 文件。Spring Boot 不需要集成任何特殊的工具，所以你可以使用任何 IDE 或文本编辑器；同时，Spring Boot 应用也没有什么特殊之处，你可以像对待其他 Java 程序那样运行，调试它。 Maven安装 尽管可以拷贝 Spring Boot jars，但我们还是建议你使用支持依赖管理的构建工具，比如 Maven。 Spring Boot 兼容 Apache Maven 3.2 或更高版本。如果本地没有安装 Maven，你可以参考 Maven官网 上的指南。 Spring Boot 依赖使用的 groupId 为 org.springframework.boot。通常，Maven 的 pom 文件会继承 spring-boot-starter-parent 工程，并声明一个或多个依赖。 Spring Boot 的 Hello World 示例 创建 POM 文件 首先，新建一个 pom.xml 文件，这个 pom.xml 文件是构建 Maven 项目的基础。然后，打开你喜欢的文本编辑器，编写以下内容： 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 这样一个可工作的构建就完成了，然后可以在命令行中通过运行 mvn package 测试它。 编写代码 为了完成应用程序，我们需要创建一个单独的 Java 文件。Maven 默认会编译 src/main/java 下的源码，所以你需要创建那样的文件结构，并在 src/main/java 目录下添加一个名为 Example.java 的文件，代码如下： 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; @RestController 注解 @RestControlle 被称为构造型（stereotype）注解。它提示阅读代码的人这是一个支持 REST 的控制器，对于 Spring，该类扮演了一个特殊角色。在本示例中，我们的类是一个 web 控制器，所以当 web 请求进来时，Spring 会考虑是否使用它来处理。 @RequestMapping 注解 @RequestMapping 注解提供路由信息，它告诉 Spring 任何来自 “/” 路径的 HTTP 请求都应该被映射到 home 方法。@RestController 注解告诉 Spring 以字符串的形式渲染结果，并直接返回给调用者。 @EnableAutoConfiguration 注解 @EnableAutoConfiguration 注解告诉 Spring Boot 根据添加的 jar 依赖猜测你想如何配置 Spring。由于 spring-boot-starter-web 添加了 Tomcat 和 Spring MVC，所以该注解将假定你正在开发一个 web 应用，并对Spring 进行相应地设置。 main 方法 main 方法是一个标准的方法，它遵循 Java 对于一个应用程序入口点的约定。main 方法通过调用 run，将业务委托给了 Spring Boot 的 SpringApplication 类。SpringApplication 将引导我们的应用，启动 Spring，相应地启动被自动配置的 Tomcat 服务器。我们只需要将 Example.class 作为参数传递给 run 方法，以此告诉 SpringApplication 谁是主要的 Spring 组件，并传递 args 数组以暴露所有的命令行参数。 运行 到此，示例应用可以工作了。由于使用了 spring-boot-starter-parent POM，这样就有了一个非常有用的运行目标来启动程序。在项目根目录下输入 mvn spring-boot:run 启动应用。 如果没有错误或者警告，那么打开浏览器输入 localhost:8080，应该可以看到如下输出： 1Hello World! 注意：可以点击 Ctrl + C 关闭应用程序。","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.luckylight6.com/categories/Spring-Boot/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.luckylight6.com/tags/Spring-Boot/"}]},{"title":"初探 Linux 之安装 Nginx 及搭建集群","slug":"Linux/初探 Linux 之安装 Nginx 及搭建集群","date":"2017-02-06T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2017/02/07/Linux/初探 Linux 之安装 Nginx 及搭建集群/","link":"","permalink":"http://blog.luckylight6.com/2017/02/07/Linux/初探 Linux 之安装 Nginx 及搭建集群/","excerpt":"","text":"本文将介绍如何 CentOS 系统中安装和配置 Nginx 最新版以及使用 Nginx 搭建 Tomcat 集群，并完成负载均衡。 Nginx Nginx 是一款高性能的 HTTP 服务器和反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师 Igor Sysoev 所开发，官方测试 Nginx 能够支支撑 5 万并发链接，并且 CPU、内存等资源消耗却非常低，运行非常稳定。 安装 Nginx 将 Nginx 的 tar 包上传到服务器： 1rz 然后选择需要上传的文件。 在 /usr/ 中创建一个目录 nginx： 1mkdir nginx 解压 Nginx 的 tar 包到 /usr/nginx： 1tar -xvf nginx-1.12.0.tar.gz -C /usr/nginx 安装依赖： gcc 安装 Nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，需要安装 gcc。 1yum install gcc-c++ pcre PCRE（Perl Compatible Regular Expressions）是一个 Perl 库，包括 perl 兼容的正则表达式库。Nginx 的 HTTP 模块使用 pcre 来解析正则表达式，所以需要在 Linux 上安装 pcre 库。 1yum install pcre pcre-devel 注：pcre-devel 是使用 pcre 开发的一个二次开发库。Nginx 也需要此库。 zlib zlib 库提供了很多种压缩和解压缩的方式，Nginx 使用 zlib 对 HTTP 包的内容进行 gzip，所以需要在 Linux 上安装 zlib 库。 1yum install zlib zlib-devel OpenSSL OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。 Nginx 不仅支持 HTTP 协议，还支持 HTTPS（即在 SSL 协议上传输 HTTP），所以需要在 Linux 安装 OpenSSL 库。 1yum install openssl openssl-devel 编译 Nginx： 进入 nginx 目录，执行： 1./configure 安装 Nginx： 12makemake install 80 端口放行且将该设置添加到防火墙的规则中： 12/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT/etc/rc.d/init.d/iptables save 启动 Nginx： 12cd /usr/local/nginx/sbin./nginx 其他常用命令 关闭 Nginx： 相当于找到 Nginx 进程 kill 1./nginx -s stop 退出命令： 1./nginx -s quit 动态加载配置文件： 1./nginx -s reload 搭建集群 创建两个目录： 12mkdir tomcat1mkdir tomcat2 将 Tomcat 的 tar 包分别解压到两个目录： 12tar -xvf apache-tomcat-7.0.77.tar.gz -C ./tomcat1tar -xvf apache-tomcat-7.0.77.tar.gz -C ./tomcat2 将项目的 war 包分别放入两个 Tomcat 的 webapps 目录下： 12cp test.war ./tomcat1/apache-tomcat-7.0.77/webappscp test.war ./tomcat2/apache-tomcat-7.0.77/webapps 修改两个 Tomca t的端口号： 12vim /root/tomcat1/apache-tomcat-7.0.77/conf/server.xmlvim /root/tomcat2/apache-tomcat-7.0.77/conf/server.xml 修改 Nginx 的配置为文件： 1vim /usr/local/nginx/comf/nginx.conf 找到 server {，在之前加入： 12345upstream 服务名 &#123; server 127.0.0.1:8090; server 127.0.0.1:8100; ip_hash;&#125; 然后在 server { 下找到 location / {，在其中加入： 1proxy_pass http://服务名; 启动两个服务器： 12sh ~/tomcat1/apache-tomcat-7.0.77/bin/startup.shsh ~/tomcat2/apache-tomcat-7.0.77/bin/startup.sh 打开浏览器，输入： 1http://主机:80/项目名 如果能够成功打开，证明集群搭建成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.luckylight6.com/tags/Tomcat/"}]},{"title":"初探 Linux 之安装 Tomcat 及发布项目","slug":"Linux/初探 Linux 之安装 Tomcat 及发布项目","date":"2017-02-04T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2017/02/05/Linux/初探 Linux 之安装 Tomcat 及发布项目/","link":"","permalink":"http://blog.luckylight6.com/2017/02/05/Linux/初探 Linux 之安装 Tomcat 及发布项目/","excerpt":"","text":"本文将介绍如何 CentOS 系统中安装和配置 Tomcat7 以及在 Tomcat 中发布项目。 安装 Tomcat Tomcat 的安装相对于 JDK 和 MySQL 来说简单了不少。 首先，在 /usr/ 目录下创建一个目录 tomcat： 12cd /usr/mkdir tomcat 然后将 Tomcat 的 tar 包移动到到 /usr/tomcat： 1mv apache-tomcat-7.0.77.tar.gz /usr/tomcat 解压 Tomcat： 1tar -xvf apache-tomcat-7.0.77.tar.gz 启动 Tomcat： 12cd /usr/tomcat/apache-tomcat-7.0.77/binsh startup.sh 将 8080 端口放行且将该设置添加到防火墙的规则中： 12/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT/etc/rc.d/init.d/iptables save 在浏览器中输入： 1http://主机:3306 如果能看到 Tomcat 的启动页面，就证明安装成功了。 发布项目 准备数据库和表 备份数据库： 1mysqldump -u用户名 -p密码 数据库 &gt; 备份的路径 将备份上传到服务器： 1rz 然后选择文件。 登录 MySQL： 1mysql -u用户名 -p密码 创建数据库： 1create database 数据库; 选择数据库： 1use 数据库; 还原数据库： 1source 备份文件路径 准备项目 将项目打成 war 包： war 包特点是只要 Tomcat 启动，war 包会自动解压。 方式一 在 Eclipse 中，右击项目，选择 Export： 然后选择导出为 WAR FILE： 最后，选择保存路径，完成即可。 方式二 打开终端，进入项目所在目录，执行： 1jar -cvf war包名 将 war 包上传： 1rz 然后选择文件。 将 war 包移动到 Tomcat 的 webapps 目录下： 1mv store.war /usr/tomcat/apache-tomcat-7.0.77/webapps 打开浏览器，输入： 1http://主机:3306/项目名 如果能够成功打开，证明项目发布成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"},{"name":"Tomcat","slug":"Tomcat","permalink":"http://blog.luckylight6.com/tags/Tomcat/"}]},{"title":"初探 Linux 之安装 MySQL","slug":"Linux/初探 Linux 之安装 MySQL","date":"2017-02-03T16:00:00.000Z","updated":"2019-03-17T12:15:54.384Z","comments":true,"path":"2017/02/04/Linux/初探 Linux 之安装 MySQL/","link":"","permalink":"http://blog.luckylight6.com/2017/02/04/Linux/初探 Linux 之安装 MySQL/","excerpt":"","text":"本文将介绍如何 CentOS 系统中安装和配置最新版的 MySQL 数据库。 查询是否已安装 MySQL 检测系统是否已经安装过 MySQL 或其依赖，若已装过要先将其删除，否则后续安装时会报错。 命令如下： 1rpm -qa | grep mysql --color 卸载 MySQL 命令如下： 1rpm -e --nodeps 包 上个命令中的包表示在步骤一中查询的出来的结果。 上传文件 由于我是在腾讯云的服务器上安装 MySQL，而且我已经本地下载好了最新版的 MySQL，因此我需要将已经下载好的 MySQL 上传到服务器中。 执行命令： 1rz 然后，选择需要上传的文件。 解压上传的文件 命令如下： 1tar -xvf mysql-5.7.18-1.el6.i686.rpm-bundle.tar 安装依赖 命令如下： 12rpm -ivh mysql-community-common-5.7.18-1.el6.i686.rpmrpm -ivh mysql-community-libs-5.7.18-1.el6.i686.rpm 安装 MySQL 客户端 命令如下： 1rpm -ivh mysql-community-client-5.7.18-1.el6.i686.rpm 安装 MySQL 服务端 命令如下： 1rpm -ivh mysql-community-server-5.7.18-1.el6.i686.rpm 设置 mysqld 服务开机启动 命令如下： 1chkconfig mysqld on 启动 myslqd 服务 命令如下： 1service mysqld start 给 root 账户设置密码 根据官方文档所述，MySQL 安装完成后，会在 /var/log/mysqld.log 文件中给 root 账户生成一个默认的密码。但是，我安装完成后并没有发现那个密码。通过在查阅各种资料，下面给出一个给 root 用户设置密码的方式。 修改配置文件 1vim /etc/my.cnf 找到 [mysqld] 在之后添加 1skip-grant-tables 重启 mysqld 服务 1service mysqld restart 直接登录 MySQL 而不需要密码 1mysql -u root 登录成功后，执行 12update mysql.user set authentication_string = password('新密码') where user = 'root';flush privileges; 退出 MySQL，到 my.cnf 中把第 2 步添加的 skip-grant-tables 去掉，重启 mysqld 服务 取消 MySQL 默认密码强度 由于 MySQL5.7 默认安装了密码安全检查插件（validate_password），默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。否则会提示 ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 错误。 123set global validate_password_policy = 0;set global validate_password_mixed_case_count = 0;set global validate_password_length = 3; 设置新密码 1SET PASSWORD = PASSWORD('新密码'); 修改字符集为 UTF-8 执行命令： 1vim /etc/my.cnf 在 [mysqld] 部分添加： 1character-set-server=utf8 在文件末尾新增 [client] 段，并在 [client] 段添加： 1default-character-set=utf8 修改好之后重启 mysqld 服务： 1service mysqld restart 添加远程访问权限 登录 MySQL 1mysql -u root -p 使用 MySQL 数据库 12use mysql;update user set host = '%' where user = 'root'; 重启 mysqld 服务 1service mysqld restart 将 3306 端口放行且将该设置添加到防火墙的规则中 命令如下： 12/sbin/iptables -I INPUT -p tcp --dport 3306 -j ACCEPT/etc/rc.d/init.d/iptables save","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.luckylight6.com/tags/MySQL/"}]},{"title":"初探 Linux 之安装 JDK","slug":"Linux/初探 Linux 之安装 JDK","date":"2017-02-02T16:00:00.000Z","updated":"2019-03-17T12:15:54.384Z","comments":true,"path":"2017/02/03/Linux/初探 Linux 之安装 JDK/","link":"","permalink":"http://blog.luckylight6.com/2017/02/03/Linux/初探 Linux 之安装 JDK/","excerpt":"","text":"本文将介绍如何 CentOS 系统中安装和配置最新版的 Oracle 的 JDK。 查询是否已安装 JDK 首先检查系统中是否已安装 OpenJDK，因为 Linux 一般都自带 OpenJDK。 命令如下： 1rpm -qa | grep java 卸载系统自带 JDK 由于我们在开发的时候一般使用的是 Oracle 的 JDK，因此我们需要卸载系统自带的 JDK。 命令如下： 1rpm -e --nodeps 包 上个命令中的包表示在步骤一中查询的出来的结果。 上传文件 由于我是在腾讯云的服务器上安装 JDk，而且我已经本地下载好了最新版的 JDK，因此我需要将已经下载好的 JDk 上传到服务器中。 首先我们需要在远程客户端（我使用的是 XShell）中安装文件上传下载工具： 1yum install -y lrzsz 下一步，将本地的 JDK 上传到服务器，执行命令： 1rz 然后，选择需要上传的文件。 安装 JDK 首先，进入 JDK 文件所在的目录，然后执行命令： 1rpm -ivh rpm文件 安装依赖 1yum install glibc.i686 配置环境变量 执行命令： 1vim /etc/profile 在末尾添加： 123456# set java environmentJAVA_HOME=/usr/java/jdk1.8.0_131JRE_HOME=/usr/java/jdk1.8.0_131/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 然后保存退出，执行命令，是修改立即生效 1source /etc/profile","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"},{"name":"JDK","slug":"JDK","permalink":"http://blog.luckylight6.com/tags/JDK/"}]},{"title":"初探 Linux 之常用系统命令","slug":"Linux/初探 Linux 之常用系统命令","date":"2017-01-22T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2017/01/23/Linux/初探 Linux 之常用系统命令/","link":"","permalink":"http://blog.luckylight6.com/2017/01/23/Linux/初探 Linux 之常用系统命令/","excerpt":"","text":"常用系统命令 查看所有进程 示例： 1ps -ef 显示系统当前时间 示例： 1date 设置系统当前时间 示例： 1data -s \"2017-04-20 22:02:18\" 显示磁盘信息 参数： 1-h 友好的显示磁盘信息 示例： 12dfdf -h 创建一个空文件 示例： 1touch a.txt 在当前目录创建 a.txt 文件 下载 wget 是一个从网络上自动下载文件的自由工具，支持通过 HTTP、HTTPS、FTP 三个最常见的 TCP/IP 协议下载，并可以使用 HTTP 代理。wget 名称的由来是 “World Wide Web” 与 “get” 的结合。 格式： 1wget [URL] 示例： 1wget http://nginx.org/download/nginx-1.9.12.tar.gz 重定向输出 &gt;：重定向输出，覆盖原有内容 1cat /etc/passwd &gt; a.txt 将输出定向到a.txt中 &gt;&gt;：重定向输出，又追加功能 1cat /etc/passwd &gt;&gt; a.txt 输出并且追加 管道 管道是 Linux 命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。用符号 | 表示。 示例： 12ls --help | more 分页查询帮助信息ps –ef | grep java 查询名称中包含java的进程 显示内存状态 参数： 1-m 以MB为单位显示内存状态 示例： 1free -m 显示，管理执行中的程序 示例： 1top 清屏 示例： 1clear 查找 格式： 1gref 关键字 参数： 123--color 高亮显示-Ax 显示查找结果之前的x行-Bx 显示查找结果之后的x行 杀掉某一进程 杀掉某一编号的进程 示例： 1kill 2868 强制杀掉某一编号的进程 示例： 1kill -9 2868 显示当前所在目录 示例: 1pwd 显示当前目录的大小 示例： 1du -h 显示当前登入系统的用户信息 示例： 1who 查看当前主机名 示例： 1hostname 修改当前主机名 示例： 1vi /etc/sysconfig/network 显示系统信息 参数： 1-a 显示本机详细信息 示例： 12unameuname","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"}]},{"title":"初探 Linux 之其他常用命令","slug":"Linux/初探 Linux 之其他常用命令","date":"2017-01-20T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2017/01/21/Linux/初探 Linux 之其他常用命令/","link":"","permalink":"http://blog.luckylight6.com/2017/01/21/Linux/初探 Linux 之其他常用命令/","excerpt":"","text":"常用网络管理命令 显示网络设备 示例： 1ifconfig 启用 eth0 网卡 示例： 1ifconfig eth0 up 停用 eth0 网卡 示例： 1ifconfig eth0 down 测试网络状况 格式： 1ping 主机或者域名 查看所有网络端口 示例： 1netstat -an 常用用户管理命令 添加用户 参数： 1-d 指定用户 home 目录 格式： 1useradd 用户名 设置、修改密码 示例： 1passwd 用户名 删除用户 参数： 1-r 删除用户以及 home 目录 格式： 1userdel 用户名 切换用户 格式： 12ssh -l 用户名 -p 22 主机su - 用户名 查看一个用户的UID和GID： 格式： 1id 用户名 常用组管理命令 当在创建一个新用户时，若没有指定它所属于的组，就建立一个和该用户同名的私有组。 创建组 格式： 1groupadd 组名 创建用户时指定组 格式： 1useradd 用户名 –g 组名 删除组 如果该组有用户成员，必须先删除用户才能删除组。 格式： 1groupdel 组名 常用权限管理命令 文件权限 通过 ll 命令展示的列表 以 d 开始的是目录文件 以 - 开始的是普通文件 以 l 开始的是符号链接 文件权限 r 表示可读 w 表示可写 x 表示可执行 - 表示无权限 假设通过 ll 命令展示的文件列表中的某个文件的权限为 -rwxrwxrwx，那么： - 表示文件类型 第一个 rwx 表示当前用户的操作权限 第二个 rwx 表示当前组的操作权限 第三个 rwx 表示其他用户的操作权限 更改文件或者目录的权限 格式： 1chmod 权限 文件或者目录 示例： 12chmod 755 1.txtchmod u=rwx,g=rx,o=rx 1.txt 更改当前的目录或文件的所属用户和组 格式： 1chown 用户名:组名 文件名 更改目录中的所有的子目录及文件的所属用户和组 格式： 1chown -R 用户名:组名 目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"}]},{"title":"初探 Linux 之常用命令","slug":"Linux/初探 Linux 之常用命令","date":"2017-01-19T16:00:00.000Z","updated":"2019-03-17T12:15:54.385Z","comments":true,"path":"2017/01/20/Linux/初探 Linux 之常用命令/","link":"","permalink":"http://blog.luckylight6.com/2017/01/20/Linux/初探 Linux 之常用命令/","excerpt":"","text":"Linux 概述 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。它能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 Linux 版本 Linux 的版本分为两种： 内核版：在 Linus 领导下的内核小组开发维护的系统内核的版本号 发行版：一些组织和公司根据自己发行版的不同而自定的 Linux 目录结构 Linux 常用命令 切换目录 示例： 12345cd app 切换到app目录cd .. 切换到上一层目录cd / 切换到系统根目录cd ~ 切换到用户主目录cd - 切换到上一个所在目录 列出文件列表 ls(list) 是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容。 格式： 1ls [参数] [路径或文件名] 示例： 123lsls -a 显示所有文件或目录（包含隐藏的文件）ls -l 缩写成ll 创建目录和移除目录 创建目录 mkdir(make directory) 命令可用来创建子目录。 示例： 12mkdir app 在当前目录下创建app目录mkdir –p app2/test 级联创建aap2以及test目录 移除目录 rmdir(remove directory) 命令可用来删除 “空” 的子目录。 示例： 1rmdir app 删除app目录 查看文件内容 cat 用于显示文件的内容。 格式： 1cat [参数] &lt;文件名&gt; 示例： 1cat yum.conf more 一般用于要显示的内容会超过一个画面长度的情况。按 空格 键显下一个画面，回车 显示下一行内容，按 q 键退出查看。 示例： 1more yum.conf less 用法和 more 类似，不同的是 less 可以通过 PgUp、PgDn 键来控制。 示例： 1less yum.conf tail tail 命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。可以使用 ctrl+c 结束查看。 示例： 12tail -10 /etc/passwd 查看后10行数据tail -f catalina.log 动态查看日志 文件操作 rm：删除 格式： 1rm [参数] 文件 参数： 12-f 不询问，直接删除-r 递归删除 示例： 1234rm a.txt 删除a.txt文件，需要用户确认rm -rf a 不询问递归删除rm -rf * 删除所有文件rm -rf /* 自杀 cp：复制 cp(copy) 命令可以将文件从一处复制到另一处。一般在使用 cp 命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。 示例： 12cp a.txt b.txt 将a.txt复制为b.txt文件cp a.txt ../ 将a.txt文件复制到上一层目录中 mv：移动或者重命名 示例： 12mv a.txt ../ 将a.txt文件移动到上一层目录中mv a.txt b.txt 将a.txt文件重命名为b.txt tar：打包或解压 tar 命令位于 /bin 目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般 Linux 上常用的压缩方式是选用 tar 将许多文件打包成一个文件，再以 gzip 压缩命令压缩成 xxx.tar.gz(或称为xxx.tgz) 的文件。 参数： 123456c：创建一个新tar文件-v：显示运行过程的信息-f：指定文件名-z：调用gzip压缩命令进行压缩-t：查看压缩文件的内容-x：解开tar文件 示例： 1234567打包： tar –cvf xxx.tar ./*打包并且压缩： tar –zcvf xxx.tar.gz ./*解压 tar –xvf xxx.tar tar -xvf xxx.tar.gz -C /usr/aaa","categories":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.luckylight6.com/tags/Linux/"}]},{"title":"Servlet 实现文件下载","slug":"实战/Servlet 实现文件下载","date":"2016-10-11T16:00:00.000Z","updated":"2019-03-17T12:15:54.387Z","comments":true,"path":"2016/10/12/实战/Servlet 实现文件下载/","link":"","permalink":"http://blog.luckylight6.com/2016/10/12/实战/Servlet 实现文件下载/","excerpt":"","text":"Servlet 实现文件下载 在生活或者工作中，总是避免不了下载文件，下载的东西有各种类型，譬如图片，视频，文本，文档，音乐等等，这些东西有大有小，大的有几G到几十G，小的或许只有几K。这些东西究竟是如何从服务器下载到我们本地的呢？现在就利用 Servlet 来实现一个的文件下载功能。 前提 要想完成这个案例，需要如下技术： Java 基础 HTML 基础 会使用 Tomcat 服务器 会使用 Servlet 进行开发 了解 HTTP 协议 会使用 Response 设置响应头、响应消息行 准备工作 所谓工欲善其事，必先利其器。要完成这个案例，我们得做好准备工作。 首先，打开 Eclipse，新建一个 Dynamic Web Project。 键入项目名，选择运行时环境为 Apache Tomcat v7.0，选择 web 版本为 2.5，然后点击 Finished。 在项目的 WebContent 目录下，新建一个文件夹 download，然后将可以供给用户下载的文件存放在这个文件夹里。 在 WebContent 目录下新建一个 index.html。 代码如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 准备工作完成！ &lt;/body&gt;&lt;/html&gt; 在 WebContent -&gt; WEB-INF 目录下新建一个 web.xml 文件，这是 web2.5 版本的规范，一个 web.xml 文件可以对 web 项目进行基本的配置。 代码如下： 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;download&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 使用 Tomcat 将次项目发布，并在浏览器中预览。 将服务器启动，然后在浏览器中输入：http://localhost:8080/download。如果出现以下界面，那么恭喜你，准备工作完美完成！ 完成案例 超链接下载文件 也许有人会说，下载文件有什么难的，在 index.html 中编写几个 a 标签，将 href 属性设置为供给用户下载的文件的路径不就行了？ 那么，我就按照上述所说试验： 首先，在 index.html 中编写3个 a 标签，将 href 属性分别指向了供给用户下载的文件的路径。 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"http://localhost:8080/download/download/1.jpg\"&gt;图片&lt;/a&gt;&lt;br&gt; &lt;a href=\"http://localhost:8080/download/download/2.txt\"&gt;文本&lt;/a&gt;&lt;br&gt; &lt;a href=\"http://localhost:8080/download/download/3.doc\"&gt;文档&lt;/a&gt;&lt;br&gt; &lt;/body&gt;&lt;/html&gt; 然后，在浏览器中打开 index.html。 这样看似乎并没有什么问题，那么来点击超链接试验一下。 结果，有的文件直接在浏览器打开了，而有的文件则是下载了。这究竟是什么原因呢？原来，当浏览器能够解析该文件的 MIME类型，则直接打开该文件；若不能，则下载。 如此，看来使用超链接下载文件是行不通了。 编码下载 从以上分析可以看出，要实现文件下载并不是设置 a 标签那么简单的。那么，究竟该怎样实现文件下载功能呢？此时，就需要使用 Servlet 编码读取要下载的文件，然后写到响应流中以达到用户下载文件的目的。 在这里，我们使用 get 请求方式，将文件名放在 url 中传送给服务器，但在很多情况下使用 post 发送数据给服务器更加合适。通过 get 发送大量数据是不现实的，它有一定的局限性，在这里使用 get 方式只是为了方便。 首先，新建一个 Servlet，并编写 web.xml 设置它的访问路径： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" id=\"WebApp_ID\" version=\"2.5\"&gt; &lt;display-name&gt;download&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;DownloadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;club.luckylight.servlet.DownloadServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DownloadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/DownloadServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 然后，需要修改 index.html 页面中 a 标签的 href 属性： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;下载&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"http://localhost:8080/download/DownloadServlet?name=1.txt\"&gt;图片&lt;/a&gt;&lt;br&gt; &lt;a href=\"http://localhost:8080/download/DownloadServlet?name=2.txt\"&gt;文本&lt;/a&gt;&lt;br&gt; &lt;a href=\"http://localhost:8080/download/DownloadServlet?name=3.doc\"&gt;文档&lt;/a&gt;&lt;br&gt; &lt;/body&gt;&lt;/html&gt; 接下来，就可以开始编写 Servlet 了： 首先，从 url 中获取文件名 1String filename = request.getParameter(\"name\"); 接下来，获取根据文件名获取文件的 MIME类型 1String mimeType = getServletContext().getMimeType(filename); 然后，就需要设置文件的 MIME类型 1response.setContentType(mimeType); 上条语句的作用就是使客户端浏览器，区分不同种类的数据，并根据不同的 MIME类型 调用浏览器内不同的程序嵌入模块来处理相应的数据。例如浏览器就是通过 MIME类型 来判断文件是 gif 图片，还是 doc 文档的。 光是这些还不行，下面还要告诉浏览器 “我要下载东西” 1response.setHeader(\"content-disposition\", \"attachment;filename=\" + filename); 最后，把文件从服务器拷贝到浏览器，完成下载 12345678910111213// 定义输入流InputStream is = getServletContext().getResourceAsStream(\"/download/\" + filename);// 定义输出流ServletOutputStream os = response.getOutputStream();// 从文件中读入数据并写到输出字节流中int len = -1;byte[] bytes = new byte[1024];while ((len = is.read(bytes)) != -1) &#123; os.write(bytes, 0, len);&#125;// 关闭资源os.close();is.close(); 下面，我来测试一下： 如此看来，似乎也并没有什么问题，但是我设置的文件名都是数字，如果我将文件名都设置为中文，那么又会怎样呢？ 此时，对于 get 请求，参数追加到地址栏，会使用 utf-8 编码，服务器（Tomcat）接受到请求之后，使用 iso-8859-1 解码，所以会出现乱码，导致找不到资源。 因此，我们在获取文件名时，必须将文件名用 utf-8 解码，然后才能使用。 1String filename = new String(request.getParameter(\"name\").getBytes(\"iso-8859-1\"), \"utf-8\"); 经过上述处理后，虽然能够下载了，但又出现了：浏览器无法识别文件名。 此时，我们需要编写一个工具类，以解决这个问题。 新建一个 class，设置类名为 DownloadUtils，编写一个静态方法，作用是根据浏览器的不同把传递过来的文件名编码。 12345678910111213141516171819202122package club.luckylight.util;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import javax.servlet.http.HttpServletRequest;public class DownloadUtils &#123; public static String getFilename(HttpServletRequest request, String filename) throws UnsupportedEncodingException &#123; String userAgent = request.getHeader(\"user-agent\"); // 针对以IE或者Edge为内核的浏览器 if (userAgent.contains(\"MSIE\") || userAgent.contains(\"Trident\") || userAgent.contains(\"Edge\")) &#123; filename = URLEncoder.encode(filename, \"UTF-8\"); &#125; else &#123; // 非IE浏览器的处理 filename = new String(filename.getBytes(\"UTF-8\"), \"ISO-8859-1\"); &#125; return filename; &#125;&#125; 然后，在告诉浏览器 “我要下载东西” 之前，把文件名编码。 12String newFilename = DownloadUtils.getFilename(request, filename);response.setHeader(\"content-disposition\", \"attachment;filename=\" + newFilename); 根据测试，以上工具类可以解决主流浏览器（IE内核，Edge内核，Chrom，FireFox等）文件下载时文件名乱码问题。 完整代码 DownloadUtils.java 12345678910111213141516171819202122package club.luckylight.util;import java.io.UnsupportedEncodingException;import java.net.URLEncoder;import javax.servlet.http.HttpServletRequest;public class DownloadUtils &#123; public static String getFilename(HttpServletRequest request, String filename) throws UnsupportedEncodingException &#123; String userAgent = request.getHeader(\"user-agent\"); // 针对以IE或者Edge为内核的浏览器 if (userAgent.contains(\"MSIE\") || userAgent.contains(\"Trident\") || userAgent.contains(\"Edge\")) &#123; filename = URLEncoder.encode(filename, \"UTF-8\"); &#125; else &#123; // 非IE浏览器的处理 filename = new String(filename.getBytes(\"UTF-8\"), \"ISO-8859-1\"); &#125; return filename; &#125;&#125; DownloadServlet.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package club.luckylight.servlet;import java.io.IOException;import java.io.InputStream;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import club.luckylight.util.DownloadUtils;public class DownloadServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取文件名，并设置编码 String filename = new String(request.getParameter(\"name\").getBytes(\"iso-8859-1\"), \"utf-8\"); // 获取文件的mime类型 String mimeType = getServletContext().getMimeType(filename); // 设置文件的mime类型 response.setContentType(mimeType); // 文件名编码 String newFilename = DownloadUtils.getFilename(request, filename); // 设置下载头信息 response.setHeader(\"content-disposition\", \"attachment;filename=\" + newFilename); // 对拷流 InputStream is = getServletContext().getResourceAsStream(\"/download/\" + filename); ServletOutputStream os = response.getOutputStream(); int len = -1; byte[] bytes = new byte[1024]; while ((len = is.read(bytes)) != -1) &#123; os.write(bytes, 0, len); &#125; // 关闭资源 os.close(); is.close(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 总结 至此，文件下载案例就完成了。其中有许多小细节并没有处理，如发现有什么错误，请多多指点。 这也是我第一次写一个案例，希望大家喜欢。","categories":[{"name":"实战","slug":"实战","permalink":"http://blog.luckylight6.com/categories/实战/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://blog.luckylight6.com/tags/Servlet/"},{"name":"Web","slug":"Web","permalink":"http://blog.luckylight6.com/tags/Web/"}]},{"title":"Servlet 实现文件上传","slug":"实战/Servlet 实现文件上传","date":"2016-10-10T16:00:00.000Z","updated":"2019-03-17T12:15:54.387Z","comments":true,"path":"2016/10/11/实战/Servlet 实现文件上传/","link":"","permalink":"http://blog.luckylight6.com/2016/10/11/实战/Servlet 实现文件上传/","excerpt":"","text":"Servlet 实现文件上传 所谓文件上传就是将本地的文件发送到服务器中保存。例如我们向百度网盘中上传本地的资源或者我们将写好的博客上传到服务器等等就是典型的文件上传。 3.0 上次完成文件下载功能使用的是 Servlet 2.5，但是想要完成文件上传，那么继续使用 Servlet 2.5 肯定不是一个好的选择，因此我们使用 Servlet 3.0 来完成文件上传。下面我来简单介绍一下 Servlet 3.0 的新特性： 新增的注解支持 该版本新增了若干注解，用于简化 Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得 web.xml 部署描述文件从该版本开始不再是必选的了。 HttpServletRequest 对文件上传的支持 此前，对于处理上传文件的操作一直是让开发者头疼的问题，因为 Servlet 本身没有对此提供直接的支持，需要使用第三方框架来实现，而且使用起来也不够简单。如今这都成为了历史，Servlet 3.0 已经提供了这个功能，而且使用也非常简单。 Servlet 3.0 的新特性当然肯定不止这些，但是其他的新特性在这里我们暂时还用不到，也就不做过多了解了。 必要条件 想要完成文件上传，肯定不是这么简单，它对浏览器端和服务器端都有许多的要求。 对浏览器的要求： 一个文件的大小一般肯定不止 1 KB，既然这样，那么要上传一个文件肯定不能使用 get 方式了，所以上传文件时必须采用 post 方式。 2.表单中必须有一个文件上传项 &lt;input type=&quot;file&quot;&gt;，而且必须有 name 属性。 必须设置表单的 enctype 属性值为 multipart/form-data。 对服务器的要求： 当然，我们肯定得使用 Servlet 3.0。 Servlet 3.0 中接收普通上传组件（除了文件上传组件）通过 request.getParameter(String)接收，而文件上传组件通过 request.getPart(String)接收。 Servlet 3.0 要求服务器必须是 Tomcat7 及其以上。 准备工作 工欲善其事，必先利其器。 首先，打开 Eclipse，新建一个 Dynamic Web Project。 键入项目名，选择运行时环境为 Apache Tomcat v7.0，选择 Servlet 版本为 3.0，然后点击 Finished。 在项目的 WebContent 目录下，新建一个文件夹 upload，用来存放上传过来的文件。 在 WebContent 目录下新建一个 index.jsp。 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/UploadServlet\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label&gt;选择一个文件：&lt;/label&gt; &lt;input type=\"file\" name=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 使用 Tomcat 将次项目发布，并在浏览器中预览。 将服务器启动，然后在浏览器中输入：http://localhost:8080/upload。 好吧！样子有点丑，希望不要介意！如果出现以上界面，那么，准备工作就完成了！ 完成案例 首先，新建一个 Servlet，在 Servlet 3.0 我们不必再为配置 web.xml 而烦恼了，只要要在 Servlet 的类名上面一行添加一个注解： 1@WebServlet(\"/UploadServlet\") 这个注解就相当与 Servlet 2.5 中的： 12345678&lt;servlet&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;club.luckylight.upload.UploadServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;UploadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/UploadServlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 这样比较，使用注解不是简便了很多。 然后，我们还需要添加另一个注解： 1@MultipartConfig 该注解主要是为了辅助 Servlet 3.0 中 HttpServletRequest 提供的对上传文件的支持。该注解标注在 Servlet 上面，以表示该 Servlet 希望处理的请求的 MIME类型 是 multipart/form-data。 接下来，我们就需要根据上传组件的 name 属性获取它了。这里我们使用 Path request.getPart(String) 方法。 1Part part = request.getPart(\"file\"); 然后，我们就需要根据 part 获取头信息，然后根据头信息获取文件的路径。 在浏览器抓包，获取头信息为： 据此，我们可以获取文件名或者文件路径。 12String header = part.getHeader(\"content-disposition\");String path = header.substring(header.indexOf(\"filename=\") + 10, header.length() - 1); 由于获取的有可能是文件名，也有可能是文件路径，为此，有必要编写一个工具类，用来获取文件的真实名称。 12345678910111213141516/** * 根据文件的路径获取文件真实名称 * * @param path * 文件的路径 * @return 文件名称 */public static String getRealName(String path) &#123; int index = path.lastIndexOf(\"\\\\\"); if (index == -1) &#123; index = path.lastIndexOf(\"/\"); &#125; return path.substring(index + 1);&#125; 然后，调用这个方法，获得文件名。 1String name = UploadUtils.getRealName(path); 接下来，我们有必要，给每个文件分配一个存放目录，因此我又编写了一个方法，用来生成一个目录。 123456789101112131415161718/** * 根据文件名返回一个目录 * * @param name * 文件名称 * @return 目录 */public static String getDir(String name) &#123; int i = name.hashCode(); String hex = Integer.toHexString(i); int j = hex.length(); for (int k = 0; k &lt; 8 - j; k++) &#123; hex = \"0\" + hex; &#125; return \"/\" + hex.charAt(0) + \"/\" + hex.charAt(1);&#125; 到此，万事俱备，只欠东风。我们只需要将文件拷贝到服务器。 1234567891011121314151617181920212223242526// 获取文件的真实路径String realPath = this.getServletContext().getRealPath(\"/upload\" + dir);File file = new File(realPath);if (!file.exists()) &#123; file.mkdirs();&#125;// 获取输入流InputStream inputStream = part.getInputStream();// 定义输出流FileOutputStream outputStream = new FileOutputStream(new File(file, name));// 从输入流中读入数据并写到输出字节流中int len = -1;byte[] bytes = new byte[1024];while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len);&#125;// 关闭资源outputStream.close();inputStream.close();// 删除临时文件part.delete(); 下面来测试一下： 然后，在 Tomcat 的 webapps -&gt; 项目名 -&gt; upload 中就可以找到上传成功的文件了！ 最后，我们打开音乐来试验下是否真的上传成功了？ 嗯！薛之谦低沉的声音从耳机中传来，看来确实是上传成功了！ 完整代码 UploadServlet.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package club.luckylight.upload;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;import club.luckylight.util.UploadUtils;@WebServlet(\"/UploadServlet\")@MultipartConfigpublic class UploadServlet extends HttpServlet &#123; private static final long serialVersionUID = 5661013723204858883L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 获取文件上传组件 Part part = request.getPart(\"file\"); // 获取文件的路径 String header = part.getHeader(\"content-disposition\"); String path = header.substring(header.indexOf(\"filename=\") + 10, header.length() - 1); // 获取文件名 String name = UploadUtils.getRealName(path); // 获取文件的存放目录 String dir = UploadUtils.getDir(name); String realPath = this.getServletContext().getRealPath(\"/upload\" + dir); File file = new File(realPath); if (!file.exists()) &#123; file.mkdirs(); &#125; // 对拷流 InputStream inputStream = part.getInputStream(); FileOutputStream outputStream = new FileOutputStream(new File(file, name)); int len = -1; byte[] bytes = new byte[1024]; while ((len = inputStream.read(bytes)) != -1) &#123; outputStream.write(bytes, 0, len); &#125; // 关闭资源 outputStream.close(); inputStream.close(); // 删除临时文件 part.delete(); response.setContentType(\"text/html;charset=utf-8\"); response.getWriter().print(\"文件\" + name + \"上传成功！\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; UploadUtils.java 12345678910111213141516171819202122232425262728293031323334353637383940package club.luckylight.util;public class UploadUtils &#123; /** * 根据文件的路径获取文件真实名称 * * @param path * 文件的路径 * @return 文件名称 */ public static String getRealName(String path) &#123; int index = path.lastIndexOf(\"\\\\\"); if (index == -1) &#123; index = path.lastIndexOf(\"/\"); &#125; return path.substring(index + 1); &#125; /** * 根据文件名返回一个目录 * * @param name * 文件名称 * @return 目录 */ public static String getDir(String name) &#123; int i = name.hashCode(); String hex = Integer.toHexString(i); int j = hex.length(); for (int k = 0; k &lt; 8 - j; k++) &#123; hex = \"0\" + hex; &#125; return \"/\" + hex.charAt(0) + \"/\" + hex.charAt(1); &#125;&#125; 总结 这样，文件上传案例就完成了，希望大家喜欢。","categories":[{"name":"实战","slug":"实战","permalink":"http://blog.luckylight6.com/categories/实战/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Servlet","slug":"Servlet","permalink":"http://blog.luckylight6.com/tags/Servlet/"},{"name":"Web","slug":"Web","permalink":"http://blog.luckylight6.com/tags/Web/"}]},{"title":"Java SE学习（五）之Java的基础语法（下）","slug":"Java SE学习/Java SE学习（五）之Java的基础语法（下）","date":"2016-09-16T16:00:00.000Z","updated":"2019-03-17T12:15:54.387Z","comments":true,"path":"2016/09/17/Java SE学习/Java SE学习（五）之Java的基础语法（下）/","link":"","permalink":"http://blog.luckylight6.com/2016/09/17/Java SE学习/Java SE学习（五）之Java的基础语法（下）/","excerpt":"","text":"Java SE学习（五）之Java的基础语法（下） 流程控制语句 语句是每种程序设计语言必不可少的一部分，当然，Java 也不例外。它具有特定的语法规则，用来控制程序的运行。Java 提供了多种语句来控制程序的流程，它们可以分为： 表达式语句 复合语句 分支语句 循环语句 跳转语句 接下来将详细介绍各种语句。 表达式语句 所谓表达式语句，就是在表达式的后面加上一个分号 ;。分号是语句终结符，出了复合语句外，其他任何 Java 语句都必须以分号结束。 表达式和表达式语句的区别在于表达式代表的是一个数值，而表达式语句代表的是一个动作。最常见的表达式语句就是赋值语句。 以下是一些典型的表达式语句： 1234a += 3;++a;b = a &gt;&gt; 2;a = (int) Math.random(); 复合语句 复合语句又称为块语句。它的格式如下： 123&#123; 语句序列&#125; 即复合语句是以一个左花括号 { 开始，以一个右花括号 } 结束，中间的 语句序列 可以是一个或者多个任何合法的 Java 语句。需要注意的是：右花括号 } 后面没有分号 ;。 复合语句是非常有用的，因为在分支语句和循环语句的控制体中，只允许一条简单语句，但实现一个功能往往需要多条语句。这时候就可以使用复合语句，放到在控制体中。 Java 规定，在复合语句中定义的变量被称为局部变量，其作用域是左花括号 { 到右花括号 }，即整个复合语句。 分支语句 在 Java 中有两种类型的分支语句，它们分别是： if 语句 switch 语句 if 语句 单一的 if 语句 if 语句由一个布尔表达式后跟一个或多个语句组成。 使用格式： 12if (exp) statement exp 可以是 Java 中任意合法的关系表达式、逻辑表达式或者 boolean 变量，但是必须放在括号内。 statement 只能是一条语句，这条语句可以是简单语句或块语句。 其功能是，如果表达式 exp 的值为真，则执行 statement 所表示的操作，否则 statement 不执行，继续后续语句。 例如： 12345678910public class Test &#123; public static void main(String args[]) &#123; int x = 10; if( x &lt; 20 ) &#123; System.out.print(\"This is if statement\"); &#125; &#125;&#125; 其结果为： 1This is if statement if…else 语句 任何 if 语句后面可以跟一个可选的 else 语句，当布尔表达式为 false，语句被执行。 使用格式： 1234if (exp) statement1else statement2 其功能是，如果表达式 exp 的值为真，则执行 statement1 所表示的操作，否则执行 statement2 所表示的操作。 例如： 123456789101112public class Test &#123; public static void main(String args[]) &#123; int x = 30; if( x &lt; 20 ) &#123; System.out.print(\"This is if statement\"); &#125; else &#123; System.out.print(\"This is else statement\"); &#125; &#125;&#125; 其结果为： 1This is else statement if…else if…else 语句 if 后面可以跟一个可选的 else if…else 语句，在测试不同条件下单一的 if 语句和 else if 语句是非常有用的。 当使用 if…else if…else 语句时有几点要牢记： 一个 if 语句可以有0个或一个 else 语句 且它必须在 else if 语句的之后。 一个 if 语句 可以有0个或多个 else if 语句且它们必须在 else 语句之前。 一旦 else if 语句成功, 余下 else if 语句或 else 语句都不会被测试执行。 使用格式： 1234567891011if (exp1) statement1else if (exp2) statement2else if (exp3) statement3...else if (exp m) statement melse statement n 例如： 12345678910111213141516public class Test &#123; public static void main(String args[]) &#123; int x = 30; if( x == 10 ) &#123; System.out.print(\"Value of X is 10\"); &#125; else if( x == 20 ) &#123; System.out.print(\"Value of X is 20\"); &#125; else if( x == 30 ) &#123; System.out.print(\"Value of X is 30\"); &#125; else &#123; System.out.print(\"This is else statement\"); &#125; &#125;&#125; 其结果为： 1Value of X is 30 嵌套 if 语句 在 Java 中可以嵌套使用 if 语句，这意味着你可以在一个 if 或 else if 语句中使用一个 if 或 else if 语句。 使用格式： 12345678910if (exp1) if (exp2) statement1 else statement2else if (exp3) statement3 else statement4 需要注意 if 和 else 的配对关系，Java 规定，else 总是与它上面最近的、未曾匹配的 if 配对。 例如： 12345678910111213public class Test &#123; public static void main(String args[]) &#123; int x = 30; int y = 10; if( x == 30 ) &#123; if( y == 10 ) &#123; System.out.print(\"X = 30 and Y = 10\"); &#125; &#125; &#125;&#125; 其结果为： 1X = 30 and Y = 10 switch 语句 Java 提供了 switch…case 语句，专门用来处理 多选一 的情况，故又称之为多路选择语句。 使用格式： 123456789101112131415switch (exp) &#123; case value1: statement1 break; case value2: statement2 break; ... case value m: statement m break; default: statement n break;&#125; switch 语句有以下规则： 在 switch 语句中使用的变量可以是 byte、short、int、char、枚举类型、String（JDK7 新特性）。 在一个 switch 语句中可以有任何数量的 case 语句。每个 case 后跟着即将被比较的值和一个冒号。 对于 case 的值必须是相同的数据类型作为开关变量，它必须是一个常量或文字。 当被启动了的变量与 case 是相等的，那 case 后的语句将执行，一直到 break 为止。 当达到一个 break 语句，switch 终止，并且控制流跳转到跟着 switch 语句的下一行。 不是每一个 case 需要包含一个 break。如果没有出现 break，控制流将贯穿到后面的 case 直到 break 为止。 switch 语句可以有一个可选默认 case （default），它可以出现在 switch 的结束处。在执行一项任务时没有任何 case 是真，那它就可被使用。 例如： 1234567891011121314151617181920212223242526public class Test &#123; public static void main(String args[])&#123; char score = 'C'; switch(score) &#123; case 'A' : System.out.println(\"Excellent!\"); break; case 'B' : case 'C' : System.out.println(\"Well done\"); break; case 'D' : System.out.println(\"You passed\"); break; case 'F' : System.out.println(\"Better try again\"); break; default : System.out.println(\"Invalid grade\"); break; &#125; System.out.println(\"Your score is \" + score); &#125;&#125; 其结果为： 12Well doneYour score is a C 循环语句 while 循环 while循环是一个控制结构，可以重复的特定任务次数。 使用格式： 12while (exp) statement exp 是任意合法的关系表达式或逻辑表达式，也可以是 boolean 类型的变量或者常量 statement 是一条语句，被称为循环体。语法上规定，循环体只能是一条语句，当需要执行多条语句的时候，应该使用复合语句。 执行流程： 对表达式 exp 求值 若值为真，则执行循环体 执行完成后，再次对表达式 exp 求值，判断是否继续循环，如此反复 若值为假，则退出循环 例子： 123456789101112public class Test &#123; public static void main(String args[]) &#123; int x = 10; while( x &lt; 20 ) &#123; System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); &#125; &#125;&#125; 结果为： 12345678910value of x : 10value of x : 11value of x : 12value of x : 13value of x : 14value of x : 15value of x : 16value of x : 17value of x : 18value of x : 19 do…while 循环 do … while循环类似于while循环，不同的是一个do … while循环是保证至少执行一次。 使用格式： 123do statementwhile (exp); exp 是任意合法的关系表达式或逻辑表达式，也可以是 boolean 类型的变量或者常量 statement 是一条语句，被称为循环体。语法上规定，循环体只能是一条语句，当需要执行多条语句的时候，应该使用复合语句。 注意：do…while循环后有分号。 执行流程： 先执行一次循环体，然后对 exp 表达式求值 若值为真，则执行循环体 执行完成后，再次对表达式 exp 求值，判断是否继续循环，如此反复 若值为假，则退出循环 例子： 123456789101112public class Test &#123; public static void main(String args[]) &#123; int x = 10; do &#123; System.out.print(\"value of x : \" + x ); x++; System.out.print(\"\\n\"); &#125; while( x &lt; 20 ); &#125;&#125; 结果为： 12345678910value of x : 10value of x : 11value of x : 12value of x : 13value of x : 14value of x : 15value of x : 16value of x : 17value of x : 18value of x : 19 for 循环 Java 中的 for 循环语句使用最为灵活，不仅可以用于循环次数已知的情况，也可以用在循环次数不确定而只给出循环条件结束的情况。 使用格式： 12for (exp1; exp2; exp3) statement exp1 是循环初值表达式，它在第一次循环开始前计算，且只计算一次，其作用是给循环控制变量赋初值。 exp2 是循环条件判断表达式，它在每次循环开始之前计算，已决定能否进行循环。一般情况下，该表达式决定了循环进行的次数。 exp3 是循环控制变量调整表达式，它在每次循环结束后计算，使循环控制变量改变，从而使循环能够结束。 statement 是一条语句，被称为循环体。语法上规定，循环体只能是一条语句，当需要执行多条语句的时候，应该使用复合语句。 执行流程： 首先执行环初值表达式 其次循环条件判断表达式，判断其是真还是假： true：执行循环体；继续执行循环控制变量调整表达式，然后回到循环条件判断表达式继续执行。 false：循环结束，继续执行for循环后面的语句。 例子： 12345678910public class Test &#123; public static void main(String args[]) &#123; for(int x = 10; x &lt; 20; x = x+1) &#123; System.out.print(\"value of x : \" + x ); System.out.print(\"\\n\"); &#125; &#125;&#125; 结果为： 12345678910value of x : 10value of x : 11value of x : 12value of x : 13value of x : 14value of x : 15value of x : 16value of x : 17value of x : 18value of x : 19 增强 for 循环 增强 for 循环是 Java5 的新特性。主要用于遍历数组或者集合。 使用格式： 12for(declaration : expression) statements 声明: 新声明块变量，这是一种与你所正在访问数组中的元素兼容的变量。该变量在 for 块内可被利用并且它的值作为当前的数组元素将是相同的。 表达: 这个计算结果完成需要循环数组。表达式可以是一个数组变量或返回一个数组的方法调用。 statement 是一条语句，被称为循环体。语法上规定，循环体只能是一条语句，当需要执行多条语句的时候，应该使用复合语句。 例子： 1234567891011121314151617public class Test &#123; public static void main(String args[]) &#123; int [] numbers = &#123;10, 20, 30, 40, 50&#125;; for(int x : numbers ) &#123; System.out.print( x ); System.out.print(\",\"); &#125; System.out.print(\"\\n\"); String [] names =&#123;\"James\", \"Larry\", \"Tom\", \"Lacy\"&#125;; for( String name : names ) &#123; System.out.print( name ); System.out.print(\" \"); &#125; &#125;&#125; 结果为： 1210 20 30 40 50James Larry Tom Lacy 增强 for 循环的缺点：丢掉了索引信息。 当遍历集合或数组时，如果需要访问集合或数组的下标，那么最好使用旧式的方式来实现循环或遍历，而不要使用增强的for循环，因为它丢失了下标信息。 跳转语句 跳转语句 break break 语句用来实现控制转移，跳转语句可以使用在 switch 语句或者循环中，可以跳出 switch 语句或者循环。 一般的 break 语句 一般的 brreak 语句的功能是将程序流程转向所在结构之后。在 switch 语句中，break 语句使控制跳转到该 switch 语句之后。在循环语句中，break 语句使控制跳出跳出包含它当前的循环层，并从循环之后的第一条语句继续执行。它不能用于循环语句和 switch 语句之外的任何地方。 使用格式： 1break; 例子： 1234567891011121314151617181920212223242526/** * 判断一个数是否为素数。 */public class PrimeTestOne &#123; public static void main(String[] args) &#123; // 产生一个[2, 1002）内的正整数 int number = (int) (Math.random() * 1000) + 2; // 求平方根 int sqrt = (int) Math.sqrt(number); int i; for (i = 2; i &lt;= sqrt; i++) &#123; // 如果能被整除，则不是素数，立即跳出循环 if (number % i == 0) &#123; break; &#125; &#125; if (i &gt; sqrt) &#123; System.out.println(number + \"是素数\"); &#125; else &#123; System.out.println(number + \"不是素数\"); &#125; &#125;&#125; 程序的一次运行结果为： 1139是素数 带标号的 break 语句 Java 没有提供饱受争议的 goto 语句，而是为 break 语句提供了标号功能。所谓标号，就是标记某一条语句的位置。 使用格式： 123&lt;标号&gt; : &lt;语句&gt;break &lt;标号&gt;; 当执行到本条语句时，立即跳出标号所标记的语句。对于 break 而言，所标记的语句只能是包含本 break 语句的内层或者外层循环语句。 因此，上述例子也可以改写为： 123456789101112131415161718192021222324252627/** * 判断一个数是否为素数。 */public class PrimeTestTwo &#123; public static void main(String[] args) &#123; // 产生一个[2, 1002）内的正整数 int number = (int) (Math.random() * 1000) + 2; // 求平方根 int sqrt = (int) Math.sqrt(number); int i; outer: for (i = 2; i &lt;= sqrt; i++) &#123; // 如果能被整除，则不是素数，立即跳出循环 if (number % i == 0) &#123; break outer; &#125; &#125; if (i &gt; sqrt) &#123; System.out.println(number + \"是素数\"); &#125; else &#123; System.out.println(number + \"不是素数\"); &#125; &#125;&#125; 虽然使用了带标记的 break 语句，但是这两个程序是完全等价的。 跳转语句 continue continue 语句的功能是使当前执行的循环体终止，即跳过 continue 语句后面尚未执行的语句，但不结束整个循环，而是继续执行下一轮循环。 一般的 continue 语句 它的使用方式与 一般 break 语句的使用方式相同。即： 1continue; 需要注意，continue语句只能出现在循环体中。 带标号的 continue 语句 coutinue 后面也可以跟标号，它的使用与带标号的 break 语句的使用方式相同。即： 123&lt;标号&gt; : &lt;语句&gt;continue &lt;标号&gt;; 如果标号所标记的是包含 continue 的外层循环，则内存循环被终止，计算外层循环的条件判断语句，以确定是否进行下一次循环。","categories":[{"name":"Java SE学习","slug":"Java-SE学习","permalink":"http://blog.luckylight6.com/categories/Java-SE学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"Java SE学习（四）之Java的基础语法（中）","slug":"Java SE学习/Java SE学习（四）之Java的基础语法（中）","date":"2016-09-15T16:00:00.000Z","updated":"2019-03-17T12:15:54.387Z","comments":true,"path":"2016/09/16/Java SE学习/Java SE学习（四）之Java的基础语法（中）/","link":"","permalink":"http://blog.luckylight6.com/2016/09/16/Java SE学习/Java SE学习（四）之Java的基础语法（中）/","excerpt":"","text":"Java的基础语法（中） 运算符 运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算。任何一个运算符都要对一个或者多个数据进行操作，所以运算符又叫做操作符。Java 为了方便程序员对数据进行运算，提供了一些丰富的运算符，大致可以分为如下几组： 算数运算符 关系运算符 逻辑运算符 赋值运算符 位运算符 其他运算符 运算符在使用时应该注意数据类型的转换（详见 Java SE学习（三）之Java的基础语法（上）），当有若干个变量参与运算时，结果类型取决于这些变量中表示范围最大的那个变量类型。例如：参与运算的变量中有整型 int，有双精度浮点型 double，有短整型 short，那么最后的结果类型就是 double。 算数运算符 加法和减法运算符 加法运算符是 +，减法运算符是 -。它们的用法和普通数学中的用法相同，例如：3 + 5、5 - 2。它们需要运算符的两侧都有数据，因此称为双目运算符。在原生数据类型中，只有 boolean 类型不能进行加法和减法运算。 使用格式： 12&lt;exp1&gt; + &lt;exp2&gt;&lt;exp1&gt; - &lt;exp2&gt; 正值和负值运算符 正值运算符是 +，负值运算符是 -。它们看上去和加法减法运算符相同，但是它们只有右侧有数据，称为单目运算符。此外，这两个运算符都不能改变操作数本身的值。在原生数据类型中，只有 boolean 类型不能进行加法和减法运算。 使用格式： 12&lt;+&gt;&lt;exp&gt;-&lt;exp&gt; 乘法和除法运算符 乘法运算符是 *，除法运算符是 /，它们都是双目运算符，虽然看上去不像在数学中使用的 × 和 ÷，但是用法却相同。在原生数据类型中，只有 boolean 类型不能进行加法和减法运算。 使用格式： 12&lt;exp1&gt; * &lt;exp2&gt;&lt;exp1&gt; / &lt;exp2&gt; 注意：如果 / 两边的操作数都是整型数据，系统会自动对结果进行取整（不是四舍五入，而是截掉小数部分）。 取模运算符 取模运算符是 %，所谓取模实际上就是数学中的求余数，它的操作数可以是正整数，也可是是负数，甚至是浮点数。 使用格式： 1&lt;exp1&gt; % &lt;exp2&gt; 运算规则： 1a % b = a - (int)(a/b) * b 例如： 12345 % 3 = 25 % -3 = 2-5 % 3 = -2-5 % -3 = -2 自增和自减运算符 自增运算符是 ++， 自减运算符是 --，它们都是单目运算符。其中，++ 的作用是让变量的值加1，-- 的作用是让变量的值减1。它们的操作时只能是变量，不能是常量，且会改变操作数本身的值。 ++ 和 -- 既可以放在变量的前面，也可以放在变量的后面。当放在变量的前面时，表示先将变量的值加1或者减1，然后将结果作为表达式的值进行后续运算；当放在变量的后面时，表示先将变量的值作为表达式的值进行运算，然后再将变量的值加1或者减1。 使用格式： 1234&lt;变量&gt;++++&lt;变量&gt;&lt;变量&gt;----&lt;变量&gt; 关系运算符 关系运算符可以决定操作数之间的逻辑关系。例如，两个操作数是否相等，操作数1与操作数2相比谁大谁小等等。由关系运算符连接起来的表达式称为关系表达式，它的值都是 boolean 类型的，也就是只有 true 和 false 两个值。 相等运算符 Java 中的相等运算符为 ==，它是一个双目运算符。 使用格式： 1&lt;exp1&gt; == &lt;exp2&gt; 它的两侧可以是任意相同或者相容的数据或者表达式。例如： 1235 == 3(a * 3) == b + 2true == true 如果 == 两侧的值相等，则返回 true，表示等式成立；如果不相等，则返回 false，表示等式不成立。虽然 == 可以比较浮点数，但是浮点数往往不能精确表示，因此一般不使用 == 判断浮点数是否相等。 不相等运算符 Java 中的不相等运算符为 !=，它也是一个双目运算符。 使用格式： 1&lt;exp1&gt; != &lt;exp2&gt; 它的两侧可以是任意相同或者相容的数据或者表达式。例如： 1235 != 3(a * 3) != b + 2true != true 果 != 两侧的值相等，则返回 false，表示判断不成立；如果不相等，则返回 true，表示判断成立。 大小关系运算符 Java 中的大小关系运算符总共有4个，分别是 &gt;、&lt;、&gt;= 和 &lt;=，它们都是双目运算符。它们的运算规则与数学中完全相同，操作数的类型可以是整型或者浮点型。 使用格式： 1234&lt;exp1&gt; &gt; &lt;exp2&gt;&lt;exp1&gt; &lt; &lt;exp2&gt;&lt;exp1&gt; &gt;= &lt;exp2&gt;&lt;exp1&gt; &lt;= &lt;exp2&gt; 若关系成立，则返回 true，否则返回 false。 逻辑运算符 逻辑运算符用来表示一个命题 “成立” 还是 “不成立”。因此，逻辑运算符的运算结果也是 boolean类型，即true 和 false。 逻辑与运算符 逻辑与运算符是 &amp;&amp;，它是双目运算符。它的操作数可以是 boolean 类型的表达式或者数据。 使用格式： 1&lt;exp1&gt; &amp;&amp; &lt;exp2&gt; 上式表达的语义是：只有当 &lt;exp1&gt; 和 &lt;exp2&gt; 同时为 true 的时候，整个表达式的值才为 true；否则，整个表达式的值为 false。 下面是逻辑与运算符的真值表： exp1 exp2 exp1 &amp;&amp; exp2 false false false false true false true false false true true true 逻辑或运算符 逻辑或运算符是 ||，它是双目运算符。它的操作数可以是 boolean 类型的表达式或者数据。 使用格式： 1&lt;exp1&gt; || &lt;exp2&gt; 上式表达的语义是：只有当 &lt;exp1&gt; 和 &lt;exp2&gt; 同时为 false 的时候，整个表达式的值才为 false；否则，整个表达式的值为 true。 下面是逻辑或运算符的真值表： exp1 exp2 exp1||exp2 false false false false true true true false true true true true 逻辑非运算符 逻辑非运算符是 !，它是单目运算符。它的操作数可以是 boolean 类型的表达式或者数据。 使用格式： 1!&lt;exp&gt; 上式表达的语义是：当 &lt;exp&gt; 为 false 的时候，整个表达式的值为 true；反之，整个表达式的值为 false。 下面是逻辑非运算符的真值表： exp !exp false true true false 短路运算 逻辑与和逻辑或运算符具有以下特性，对于表达式： 12exp1 &amp;&amp; exp2exp1 || exp2 当以下条件有一个满足时： 在逻辑与表达式中，exp1 的计算结果为 false 在逻辑或表达式中，exp1 的计算结果为 true 则整个表达式计算完毕。因为这时已经 能够确定整个表达式的逻辑值，所以 exp2 不会被计算。这个特性，被称为短路运算。 位运算符 Java 提供了多种位运算。位运算将操作数解释为有序的 “位” 集合，这些位中的某一位或者若干位可以具有独立的含义，可以随心所欲地操作存储单元中的二进制位。位运算符通常作用于整数，且参与运算的操作数均以补码的形式出现。 按位与运算符 按位与运算符是 &amp;，它是双目运算符，功能是将参与运算的两个操作数各个对应的二进制位作 “与” 运算。只有当对应的两个二进制位均为1时，结果位才为1；否则为0。 使用格式： 1&lt;操作数&gt; &amp; &lt;操作数&gt; 例如： 123int a = 3;int b = 4;System.out.println(a &amp; b); 分析： 123456789103 的二进制：00000000 00000000 00000000 000000114 的二进制：00000000 00000000 00000000 00000100进行运算： 00000000 00000000 00000000 00000011&amp; 00000000 00000000 00000000 00000100------------------------------------- 00000000 00000000 00000000 00000000结果：0 按位或运算符 按位或运算符是 |，它是双目运算符，功能是将参与运算的两个操作数各个对应的二进制位作 “或” 运算。只有当对应的两个二进制位均为0时，结果位才为0；否则为1。 使用格式： 1&lt;操作数&gt; | &lt;操作数&gt; 例如： 123int a = 3;int b = 4;System.out.println(a | b); 分析： 123456789103 的二进制：00000000 00000000 00000000 000000114 的二进制：00000000 00000000 00000000 00000100进行运算： 00000000 00000000 00000000 00000011| 00000000 00000000 00000000 00000100------------------------------------- 00000000 00000000 00000000 00000111结果：7 按位异或运算符 按位异或运算符是 ^，它是双目运算符，功能是将参与运算的两个操作数各个对应的二进制位作 “异或” 运算。只有当对应的两个二进制位不相同时，结果位才为1；否则为0。 使用格式： 1&lt;操作数&gt; ^ &lt;操作数&gt; 例如： 123int a = 3;int b = 4;System.out.println(a ^ b); 分析： 123456789103 的二进制：00000000 00000000 00000000 000000114 的二进制：00000000 00000000 00000000 00000100进行运算： 00000000 00000000 00000000 00000011^ 00000000 00000000 00000000 00000100------------------------------------- 00000000 00000000 00000000 00000111结果：7 按位取反运算符 按位取反运算符是 ~，它是单目运算符，功能是将参与运算的操作数的各个二进制位 “按位取反”。 使用格式： 1~&lt;操作数&gt; 例如： 12int a = 3;System.out.println(~a); 分析： 123456789103 的二进制：00000000 00000000 00000000 00000011进行运算：~ 00000000 00000000 00000000 00000011------------------------------------- 11111111 11111111 11111111 11111100 补码 11111111 11111111 11111111 11111011 反码 10000000 00000000 00000000 00000100 原码结果：-4 左移位运算符 左移位运算符是 &lt;&lt;，它是双目运算符，功能是将 &lt;&lt; 左边的操作数的各个二进制位全部左移指定的位数。左移时，操作数移出左边界的位被丢弃，从右边开始用 0 填补空位。 使用格式： 1&lt;操作数&gt; &lt;&lt; &lt;移位位数&gt; 例如： 12int a = 16;System.out.println(a &lt;&lt; 2); 分析： 123456716 的二进制：00000000 00000000 00000000 00010000进行运算： 00000000 00000000 00000000 00010000(00)00000000 00000000 00000000 01000000结果：64 带符号右移位运算符 带符号右移位运算符是 &gt;&gt;，它是双目运算符，功能是将 &gt;&gt; 左边的操作数的各个二进制位全部右移指定的位数。右移时，操作数移出右边界的位被丢弃，从左边开始用 符号位 填补空位。如果原来最高位是1，则填补1；如果是0，则填补0。 使用格式： 1&lt;操作数&gt; &gt;&gt; &lt;移位位数&gt; 例如： 12int a = 16;System.out.println(a &gt;&gt; 2); 分析： 123456716 的二进制：00000000 00000000 00000000 00010000进行运算：00000000 00000000 00000000 0001000000000000 00000000 00000000 00000100(00)结果：4 不带符号右移位运算符 不带符号右移位运算符是 &gt;&gt;&gt;，它是双目运算符，功能是将 &gt;&gt;&gt; 左边的操作数的各个二进制位全部右移指定的位数。右移时，操作数移出右边界的位被丢弃，从左边开始用 0 填补空位。 使用格式： 1&lt;操作数&gt; &gt;&gt;&gt; &lt;移位位数&gt; 例如： 12int a = 16;System.out.println(a &gt;&gt;&gt; 2); 分析： 123456716 的二进制：00000000 00000000 00000000 00010000进行运算：00000000 00000000 00000000 0001000000000000 00000000 00000000 00000100(00)结果：4 赋值运算符 Java 中的赋值运算符有两种，一种是简单的赋值运算符 =，；另外一种是将 = 与其他的运算符复合在一起形成的复合赋值运算符。 简单赋值运算符 赋值运算符为 =，它是双目运算符，它不等同于数学中的等号。由赋值运算符连接的表达式，称为赋值表达式。 使用格式： 1&lt;变量&gt; = &lt;exp&gt; 在 Java 中，出现在赋值运算符左边的操作数被称为 “左值”，出现在赋值运算符右边的操作数被称为 “右值”。常量和表达式不能作为 “左值”。 复合赋值运算符 为了避免对同一存储对象的地址重复计算，提高编译效率，Java 引入了复合赋值运算符。Java 提供了 11 种复合赋值运算符，它们分别是：+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=、&amp;=、|=、^=。 例如： 123x += 6.0 等价于 x = x + 6.0z *= z + y 等价于 z = z * (x + y)a += a -= b + 5 等价于 a = a + (a = a - (b + 5)) 其他运算符 条件运算符 条件运算符同样也被称作为三元运算符，它是三目运算符。这种运算符由三个操作数组成，被用作评估布尔数学体系表达。这种运算符的目的是来决定哪些值应被赋予到变量上。 使用格式： 1&lt;exp1&gt; ? &lt;exp2&gt; : &lt;exp3&gt; 运算规则：首先计算 exp1，当其结果为 true 时，条件运算表达式取 exp2 的值作为整个表达式的值，否则取 exp3 的值作为整个表达式的值。 例如： 123456789101112public class Test &#123; public static void main(String args[])&#123; int a , b; a = 10; b = (a == 1) ? 20: 30; System.out.println( \"Value of b is : \" + b ); b = (a == 10) ? 20: 30; System.out.println( \"Value of b is : \" + b ); &#125;&#125; 结果如下： 12Value of b is : 30Value of b is : 20 instanceof 运算符 instanceof 操作符只用于对象引用变量，其功能是检查对象是否是独特类型（类型或接口类型）。如果在运算符左侧的由变量所指代的对象为右侧的类型或接口类型通过 IS-A 检查，那么结果为真。 使用格式： 1(Object reference variable) instanceof (class/interface type) 例如： 123456789public class Test &#123; public static void main(String args[])&#123; String name = \"James\"; // following will return true since name is type of String boolean result = name instanceof String; System.out.println(result); &#125;&#125; 结果为： 1true 下划线分隔符 下划线分隔符是 JDK7 的新特性，当遇到一个特别长的数字时，就可以使用下划线分隔符 _，根据使用者的习惯对数字进行分割，增强可读性。例如： 1int num = 12_0000_0000; 从上面的例子就可以看出来，当对一个较大的数字使用了下划线分隔符后，我们就能很容易地知道它是12亿。 当然，它也有不适用的地方： 在数字的开头 在小数点的左边或者右边 在 long 或者 float 类型的后缀符 F 或者 L 的左边或者右边 不能拆散二进制、八进制或者十六进制的标识符，比如原本的 0x 被拆成 0_x","categories":[{"name":"Java SE学习","slug":"Java-SE学习","permalink":"http://blog.luckylight6.com/categories/Java-SE学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"Java SE学习（三）之Java的基础语法（上）","slug":"Java SE学习/Java SE学习（三）之Java的基础语法（上）","date":"2016-09-14T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2016/09/15/Java SE学习/Java SE学习（三）之Java的基础语法（上）/","link":"","permalink":"http://blog.luckylight6.com/2016/09/15/Java SE学习/Java SE学习（三）之Java的基础语法（上）/","excerpt":"","text":"要学习一门程序设计语言，首先必须得学习它的语法，这部分内容对于大部分人来说是非常枯燥的，因为要记忆的内容非常多，但是要想学好 Java，就必须了解这部分的内容。语法格式只是学习时最基础的知识，在实际的开发中，需要根据程序的需要，使用恰当的格式去实现程序逻辑，所以语法一定要熟练。这部分内容对于具有 C/C++ 编程经验的程序员来说，只需要快速的浏览一下，注意其中的差异就行了。 注释 注释（comment）是对代码功能和用途的说明。在程序中编写适当的注释，将使程序代码更容易阅读，增强代码的可维护性。与大多数程序程序设计语言一样，Java 中的注释也不会出现在可执行程序（即 .class 文件）中。因此，可以在源程序中根据需要添加任意多的注释，而不用担心代码会膨胀。 单行注释 单行注释是最常用的注释方式，只需要在要注释的内容前面加上 // 即可。例如： 1// hello world 注意：单行注释从两个斜线开始到本行结束都是注释的内容，注释内容不能换行。 多行注释 多行注释可以将任意多行的内容注释，一般用于说明比较复杂的内容，只需要将需要注释的内容用 /* 和 */ 包围起来。例如： 1234/* hello world*/ 注意：多行注释不能嵌套使用。 文档注释 文档注释可以自动地生成文档，是 Java 的特色注释格式，这种注释以 /** 开头，以 */ 结束。例如： 1234/** * @version v1.0 * @author LuckyLight */ 关键字 所谓关键字就是被 Java 语言赋予特殊含义，具有专门用途的单词，比如之前接触的 class，public，static等均为 Java 预设的关键字。组成关键字的字母全部都是小写，且不能用作常量、变量和其他标识符的名字。 常见关键字 关键字 关键字 关键字 关键字 abstract assert boolean break byte case catch char class const continue default do double else enum extends final finally float for goto if implements import instanceof int interface long native new package private protected public return short static strictfp super switch synchronized this throw throws transient try void volatile while 注意：goto 与 const 是 Java 中的保留字，即没有赋予特殊含义却仍被 Java 占用的单词 标识符 标识符即标识的符号，指程序中一切自己指定的名称，例如后续语法中涉及到的变量名称、常量名称、数组名称、方法名称、参数名称、类名、接口名、对象名等等。 组成规则 英文大小写字母 数字 货币字符（$）和下划线（_） 注意事项 数字不能开头 不可以使用关键字 严格区分大小写，不限制长度 起名时，尽量达到见名知意 标识符中常见的命名规则 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：（领域模型 的相关命名）DO / DTO / VO / DAO 等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 正例： localValue / getHttpMessage() / inputUserId 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 正例： MAX_STOCK_COUNT 反例： MAX_COUNT 抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命 名以它要测试的类的名称开始，以 Test 结尾。 POJO 类中的任何布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型 boolean isSuccess；的属性，它的方法也是 isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。 正例： 应用工具类包名为 com.alibaba.mpp.util、类名为 MessageUtils（此规则参考 spring的框架结构） 变量和常量 所谓变量,就是程序的运行过程中值会发生改变的量；所谓常量,就是程序运行过程中值不能发生改变的量。 在实际的程序中，可以根据数据在程序运行中是否发生改变，来选择应该是使用变量还是常量。 声明 由于 Java 语言是一种强类型的语言，所以变量和常量在使用以前必须首先声明，在程序中声明变量和常量的语法格式如下： 1数据类型 变量或常量名称; 变量或常量名称是该变量或常量的标识符，需要符合标识符的命名规则，在实际使用中，该名称一般和变量或常量的用途对应，这样便于程序的阅读。例如： 1int age; 赋值 变量和常量在使用前必须先赋值，给变量或常量赋值的格式为： 1变量或常量名称 = 值; 赋值时，要求值的类型需要和声明变量或常量的数据类型一致。例如： 1age = 18; 注意：= 表示赋值,将 = 右边的值赋给了左边的变量或常量。Java 中使用 == 表示相等,等价于数学中的 =。 综合使用 可以在声明变量或常量的同时，设定该变量或常量的值，语法格式如下： 1数据类型 变量或常量名称 = 值; 例如： 1int age = 18; 数据类型 Java 是一种强类型语言，这意味着必须为每一个变量声明一种数据类型，基于变量的数据类型，操作系统会进行内存分配并且决定什么将被储存在保留内存中。因此，通过给变量分配不同的数据类型，你可以在这些变量中存储整数，小数或者字字母。 在 Java 中，数据类型分为原生数据类型和引用数据类型。 原生数据类型 Java 支持 8 种原始数据类型。原始数据类型是由该语言预先定义的并用关键词命名的。 字节型（byte） 字节型是一种 8 位有正负的二进制整数，最小值是 -128(-2^7)，最大值是 127(2^7-1)，默认值为 0。 字节型数据类型主要是为了在大型数组内节省空间，主要是替代整数由于字节型比整数小 4 倍。 例如： 12byte a = 100;byte b = -50; 短整数（short） 短整数是一种 16 位有正负的二进制整数，最小值是 -32768(-2^15)，最大值是 32767(2^15-1)，默认值为 0。 短整数类型的数据也可以像字节型一样用于节省空间。短整数比整数小两倍 例如： 12short a = 10000;short b = -20000; 整数型（int） 整数型是一种 32 位有正负的二进制整数，最小值是 - 2,147,483,648(-2^31)，最大值是 2,147,483,647(2^31 -1)，默认值为 0。 整数型一般默认被应用于整数值除非担心内存不够用。 例如： 12int a = 100000;int b = -200000; 长整型（long） 长整型是一种 64 位有正负的二进制整数，最小值是 -9,223,372,036,854,775,808(-2^63)，最大值是 9,223,372,036,854,775,807 (2^63 -1)，默认值为0。 这种数据类型一般是在需要比整数型范围更大时应用。 例如： 12long a = 1000000L;long b = -20000000L; 浮点型（float） 浮点型数据是一种单精度的 32 位 IEEE 754 标准下的浮点数据，默认值是 0.0f。 浮点型数据主要是为了在大型浮点数字数组中节约内存。 浮点型数据不能用于如货币这样的精确数据。 例如： 1float a = 234.5F; 双精度型（double） 双精度型数据是一种双精度的 64 位 IEEE 754 标准下的浮点数据，默认值是 0.0d。 这种数据类型主要是默认被用于表示小数的值，一般是默认的选择。 双精度型数据不能用于如货币这样的精确数据。 例如： 1double a = 123.4; 布尔型（boolean） 布尔型数据代表一个信息比特。它只有两个可能的值：真（true）和假（false），默认值是假（false）。 这种数据类型用于真假条件下的简单标记。 例如： 1boolean a = true； 字符型（char） 字符型数据是简单的 16 位 Unicode 标准下的字符，最小值是： ‘\\u0000’ (或 0)，最大值是： ‘\\uffff’ (或 65,535 )。 字符型数据可以用来储存任意字母。 例如： 1char a ='A'; 原生数据类型的相互转换 在 Java 中，类型的转换随处可见。例如变量的定义、数值的计算以及方法的传递等等，类型转换在 Java 中具有重要的作用。在此，先简单介绍一下原生数据类型的相互转换。 要想理解数据类型的相互转换，首先必须知道以下两点： 在 Java 中各种原生数据类型所占内存的大小，如下表所示： 数据类型 所占的内存 boolean 未定 byte 1字节 char 2字节 short 2字节 int 4字节 long 8字节 float 4字节 double 8字节 在 Java 中，整数的默认数据类型为 int，浮点数的默认数据类型为 double。 隐式类型转换 在 Java 中，隐式转换由系统自动进行，无需程序员干涉，且不会损失精度。规则如下表所示： 原类型 目的类型 byte short, int, long, float, double short int, long, float, double char int, long, float, double int long, float, double long float, double float double 例如： 1byte + int 会自动转换成： 1int + int 又如： 1int + double 会转换成： 1double + double 再如： 1byte + char 会转换成： 1int + int 显式类型转换 在 Java 中，显式类型转换又被称为强制类型转换，这种转换不会自动进行，需要由程序员显式指定，而且有可能损失精度。规则如下表所示： 原类型 目的类型 byte char short byte, char char byte, short int byte, short, char long byte, short, char, int float byte, short, char, int, long double byte, short, char, int, long, float 例如： 1int a; 要想将 a 转换成 byte 类型，需要这样写： 1(byte) a; 如想将整个表达式的结果进行数据类型转换，必须将整个表达式用括号括起来。 例如： 123int a;int b;byte c; 要想将 a + b 的结果赋值给 c，则需要这样写： 1c = (byte) (a + b); 引用数据类型 引用数据类型是由类的编辑器定义的。他们是用于访问对象的。这些变量被定义为不可更改的特定类型。例如：Employee， String 等等。 类对象和数组变量就是这种引用数据类型。 任何引用数据类型的默认值都为空。 一个引用数据类型可以被用于任何声明类型和兼容类型的对象。 例如： 1String string = new String(\"hello world\"); 数据的进制表示 在 Java 中，数据默认是十进制的，如果想要使用其他进制的数据，就需要使用特殊的方式来表示。 二进制 如果想要表示二进制的数据，可以在二进制的数据前面加上 0b。这是 JDK7 的新特性。例如： 1int binaryNum = 0b1010; 八进制 如果想要表示八进制的数据，可以在八进制的数据前面加上 0。例如： 1int octNum = 010; 十六进制 如果想要表示十六进制的数据，可以在十六进制的数据前面加上 0x。例如： 1int hexNum = 0x1a;","categories":[{"name":"Java SE学习","slug":"Java-SE学习","permalink":"http://blog.luckylight6.com/categories/Java-SE学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"Java SE学习（二）之第一个Java程序","slug":"Java SE学习/Java SE学习（二）之第一个Java程序","date":"2016-09-13T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2016/09/14/Java SE学习/Java SE学习（二）之第一个Java程序/","link":"","permalink":"http://blog.luckylight6.com/2016/09/14/Java SE学习/Java SE学习（二）之第一个Java程序/","excerpt":"","text":"第一个Java程序 对于初学者来说，第一个 Java 程序太神秘，也太难了，因为需要在第一个程序中学到很多的操作，而且在操作的过程中，即使是一个很小的错误，都可以让初学者束手无策，所以学习第一个 Java 程序，一点都不简单，也需要足够的细心和耐心。 编辑第一个 Java 程序 Java 源代码可以在任意文本编辑器中进行，可以直接使用 Windows 自带的记事本，也可以使用 EditPlus，UltraEdit 等高级文本编辑工具来编写 Java 程序，还可以使用专业的 IDE（Integrated Development Environment）编写。 刚开始编写 Java 程序，最好使用记事本来编写，最好不要使用高级的 IDE 工具，以免造成依赖。 Windows 打开记事本程序的步骤如下：开始 &gt; 程序 &gt; 附件 &gt; 记事本。 然后就可以在新打开的记事本中进行代码编辑了。 下面是第一个 Java 程序： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World\"); &#125;&#125; 注意： 1、Java 源代码中的字母区分大小写。 2、Java 源代码中的标点符号均为半角字符，即英文输入模式下的标点符号。 3、Java 源代码中缩进只是为了美观和方便阅读，在实际编译时，会删除代码中每行开始和每行结束的所有空格。 保存第一个 Java 程序 在记事本中保存代码的操作步骤如下： 选择记事本的 文件 &gt; 保存 选择想要保存的路径 保存类型设置为“所有文件” 文件名为 HelloWorld.java 选择“保存”按钮保存即可 注意： 1、所有的 Java 代码，其后缀名都是 .java。 2、一个 Java 文件中只能有一个 public 类。 3、如果文件中不止一个类，文件名必须与 public 类名一致；如果文件中不止一个类，而且没有 public 类，文件名可与任一类名一致。 编译第一个 Java 程序 源代码编写保存后，就可以使用 JDK 中的编译工具来编译程序了。 所谓编译，就是将程序的源代码编译成可执行文件，Java 语言的可执行文件是后缀名为 .classs 的文件，称为类文件或字节码（bytecode）文件。 编译源代码的工具是 JDK 中 bin 目录下的 javac.exe 文件。 在命令行下编译程序的步骤如下： 打开命令提示符窗口 方式一：开始 &gt; 程序 &gt; 附件 &gt; 命令提示符。 方式二：开始 &gt; 运行 ，则输入框中输入 cmd 命令打开该窗口。 切换到源代码保存目录 首先在命令行中输入 D:，按回车键切换到 D 盘 然后输入 cd java 切换到源代码的保存路径。 则命令提示符中的提示是：D:/java&gt;。 输入编译命令 命令格式为： javac 源文件全名 例如：javac HelloWorld.java 按回车键执行该命令，如果没有任何提示，则代表编译成功，在源代码所在目录下生成 HelloWorld.class 文件，如果有一系列提示，则代表有语法错误，可以仔细检查代码书写是否有错，以及文件名或者路径是否有错。 注意：源文件全名区分大小写。 执行第一个 Java 程序 编译成功以后，就可以使用 JDK 中 bin 下的运行命令 java.exe，运行生成的程序了。运行时，执行的是class文件，即字节码文件。 运行的步骤如下： 切换到 class 文件所在的目录 输入运行命令 命令格式：java class文件名(不带后缀名) 例如：java HelloWorld 按回车键执行该命令，然后就可以在命令提示符窗口中，看到第一个 Java 程序的执行结果了，也就是在命令提示符窗口中输出一行字符： Hello World 总结 如此，第一个 Java 程序就完成了，对于初学者来说也许很困难，但只要坚持不懈，专心致志地学习、练习，相信聪明的你一定能够成功！","categories":[{"name":"Java SE学习","slug":"Java-SE学习","permalink":"http://blog.luckylight6.com/categories/Java-SE学习/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"Java SE学习（一）之Java简介与Java开发环境配置","slug":"Java SE学习/Java SE学习（一）之Java简介与Java开发环境配置","date":"2016-09-12T16:00:00.000Z","updated":"2019-03-17T12:15:54.386Z","comments":true,"path":"2016/09/13/Java SE学习/Java SE学习（一）之Java简介与Java开发环境配置/","link":"","permalink":"http://blog.luckylight6.com/2016/09/13/Java SE学习/Java SE学习（一）之Java简介与Java开发环境配置/","excerpt":"","text":"Java简介 Java 是由 Sun Microsystems 公司于1995年5月推出的 Java 面向对象程序设计语言和 Java 平台的总称。由 James Gosling 和同事们共同研发，并在1995年正式推出。 Java分为三个体系： J2SE(Java2 Platform Standard Edition，java平台标准版） J2EE(Java 2 Platform Enterprise Edition，java平台企业版) J2ME(Java 2 Platform Micro Edition，java平台微型版)。 2005年6月，JavaOne 大会召开，SUN 公司公开 Java SE 6。此时，Java 的各种版本已经更名以取消其中的数字 “2”：J2EE 更名为 Java EE, J2SE更名为 Java SE，J2ME更名为 Java ME。 主要特性 Java语言是简单的 Java 语言的语法与 C 语言和 C++ 语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java 丢弃了 C++ 中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java 语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。 Java语言是面向对象的 Java 语言提供类、接口和继承等原语，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为 implements）。Java 语言全面支持动态绑定，而 C++ 语言只对虚函数使用动态绑定。总之，Java 语言是一个纯的面向对象程序设计语言。 Java语言是分布式的 Java 语言支持 Internet 应用的开发，在基本的 Java 应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括 URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。 Java语言是健壮的 Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。对指针的丢弃是 Java 的明智选择。Java 的安全检查机制使得 Java 更具健壮性。 Java语言是安全的 Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防恶意代码的攻击。除了 Java 语言具有的许多安全特性以外，Java 对通过网络下载的类具有一个安全防范机制（类 ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类 SecurityManager）让 Java 应用设置安全哨兵。 Java语言是体系结构中立的 Java 程序（后缀为 .java 的文件）在 Java 平台上被编译为体系结构中立的字节码格式（后缀为 .class 的文件），然后可以在实现这个 Java 平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。 Java语言是可移植的 这种可移植性来源于体系结构中立性，另外，Java 还严格规定了各个基本数据类型的长度。Java 系统本身也具有很强的可移植性，Java 编译器是用 Java 实现的，Java 的运行环境是用 ANSI C 实现的。 Java语言是解释型的 如前所述，Java 程序在 Java 平台上被编译为字节码格式，然后可以在实现这个 Java 平台的任何系统中运行。在运行时，Java 平台中的 Java 解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。 Java是高性能的 与那些解释型的高级脚本语言相比，Java 的确是高性能的。事实上，Java 的运行速度随着 JIT(Just-In-Time）编译器技术的发展越来越接近于 C++。 Java语言是多线程的 在 Java 语言中，线程是一种特殊的对象，它必须由 Thread 类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为 Thread(Runnable)的构造子将一个实现了 Runnable 接口的对象包装成一个线程，其二，从 Thread 类派生出子类并重写 run 方法，使用该子类创建的对象即为线程。值得注意的是 Thread 类已经实现了 Runnable 接口，因此，任何一个线程均有它的 run 方法，而 run 方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java 语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为 synchronized）。 Java语言是动态的 Java 语言的设计目标之一是适应于动态变化的环境。Java 程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java 中的类有一个运行时刻的表示，能进行运行时刻的类型检查。 发展历史 1995年5月23日，Java语言诞生。 1996年1月，第一个JDK-JDK1.0诞生。 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术。 1996年9月，约8.3万个网页应用了JAVA技术来制作。 1997年2月18日，JDK1.1发布。 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录。 1997年9月，JavaDeveloperConnection社区成员超过十万。 1998年2月，JDK1.1被下载超过2,000,000次。 1998年12月8日，JAVA2企业平台J2EE发布。 1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）。 2000年5月8日，JDK1.3发布。 2000年5月29日，JDK1.4发布。 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机。 2001年9月24日，J2EE1.3发布。 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升。 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0。 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字&quot;2&quot;：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME。 2006年12月，SUN公司发布JRE6.0。 2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。 2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。 2011年7月28日，甲骨文发布java7.0的正式版。 Java 开发环境 JDK：Java Development Kit（Java开发必备） JRE：Java Runtime Environment（Java运行时环境） 其中，JDK包含了JRE。 JDK 的别称 jdk1.5(5.0)：Tiger，老虎 jdk1.6(6.0)：Mustang，野马 jdk1.7(7.0)：Dolphi，海豚 Java开发环境配置 安装JDK 首先我们需要下载 java 开发工具包 JDK，下载地址。 点击箭头指向的地方 选择 Accept License Agreement 选择你的电脑所对应的系统进行下载，假如是 64 位的 Windows 操作系统，就点击 jdk-8u121-windows-x64.exe 进行下载 下载成功后，双击安装包进行安装 JDK的安装跟普通软件的安装方式差不多，还有安装JDK的时候也会安装JRE，一并安装就可以了。 安装过程中可以自定义安装目录等信息，例如我们选择安装目录为 D:\\Develop\\Java\\jdk1.8.0_112。 配置环境变量 配置环境变量的目的是让 jdk1.8.0_112\\bin 目录下的工具，可以在任意目录下运行，相当于将该工具所在目录告诉了系统，当使用该工具时，由系统帮我们去找指定的目录。我的操作系统是 Windows10，步骤如下： 右击“此电脑”，点击 “属性” 点击 “高级系统设置” 切换到 “高级” 选项卡，点击 “环境变量” 在 “系统变量” 中设置 3 项属性，JAVA_HOME、PATH、CLASSPATH(大小写无所谓)，若已存在则点击 “编辑”，不存在则点击 “新建” 系统变量设置 变量名：JAVA_HOME 变量值：D:\\Develop\\Java\\jdk1.8.0_112 这里是你JDK的安装路径，可以更换 变量名：CLASSPATH 变量值：.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 记得前面有个 “.” 变量名：Path 变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; 测试环境变量是否配置成功 Win + R，键入cmd 键入命令java -version，java，javac几个命令，出现以下画面，说明环境变量配置成功 以上步骤都正确的话，就可以开始编写你的第一个 Java 程序了。","categories":[{"name":"Java SE学习","slug":"Java-SE学习","permalink":"http://blog.luckylight6.com/categories/Java-SE学习/"}],"tags":[{"name":"JDK","slug":"JDK","permalink":"http://blog.luckylight6.com/tags/JDK/"},{"name":"Java","slug":"Java","permalink":"http://blog.luckylight6.com/tags/Java/"},{"name":"Java SE","slug":"Java-SE","permalink":"http://blog.luckylight6.com/tags/Java-SE/"}]},{"title":"Markdown入门教程","slug":"工具/Markdown入门教程","date":"2016-09-10T16:00:00.000Z","updated":"2019-03-17T12:15:54.387Z","comments":true,"path":"2016/09/11/工具/Markdown入门教程/","link":"","permalink":"http://blog.luckylight6.com/2016/09/11/工具/Markdown入门教程/","excerpt":"","text":"写在前面 之前在 CSDN 写过一段时间的博客，使用的是传统的富文本编辑。最近利用 Github + Hexo 搭建了一个静态页面的个人博客，发现在上面写博客必须使用 Markdown，这才发现现在写博客几乎都在使用 Markdown。后知后觉的感觉真是不爽，因此便有了这篇 Markdown 入门教程，希望那些同我一样不会使用 Markdown 的同志受到一些启发。 认识Markdown Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown 的语法简洁明了、学习容易，不要以为它是一门语言就以为它很难，其实它很简单，而且功能比纯文本更强，因此有很多人用它写博客。 Markdown的优点 纯文本，所以兼容性极强，可以用所有文本编辑器打开。 让你专注于文字而不是排版。 格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf 等。 Markdown 的标记语法有极好的可读性。 Markdown编辑器 我在前面说过，Markdown 可以使用普通文本编辑器编写，但是在普通文本编辑器编写肯定不方便，因为你也不敢肯定你写出来是什么样子的，因此我们需要更高级的编辑器。 Windows 平台 通过我在网上寻找，发现有两款还不错，一款叫做 MarkdownPad ，另一款叫做 MarkPad，我目前使用的是 MarkdownPad。 Mac OS 平台 我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题 （Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 GitHub 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。 Web 平台 我强烈推荐简书这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。 Markdown语法 标题 标题是Markdown中最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。 语法 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注意事项 # 和「一级标题」之间建议保留一个字符的空格，这是最标准的 Markdown 写法。 粗体和斜体 Markdown 的粗体和斜体也非常简单，用 ** 包含一段文本就是粗体的语法，用一个 * 包含一段文本就是斜体的语法。 语法 12**我是粗体***我是斜体* 显示效果 我是粗体 我是斜体 注意事项 前后的 * 与要与加粗或倾斜的字体之间不能有空格。 引用 在我们写作的时候经常需要引用他人的文字，这个时候引用这个格式就很有必要了，在 Markdown 中，你只需要在你希望引用的文字前面加上 &gt; 就好了。 单层引用 语法 1&gt; 这是引用 显示效果 这是引用 嵌套引用 引用还可以嵌套，&gt;&gt; 表示引用里面再套一层引用，依次类推。例如： 语法 123&gt; 这是一级引用&gt;&gt; 这是二级引用&gt;&gt;&gt; 这是三级引用 显示效果 这是一级引用 这是二级引用 这是三级引用 注意事项 如果 &gt; 和 &gt;&gt; 嵌套使用的话，从 &gt;&gt; 退到 &gt; 时，必须之间要加一个空格或者 &gt; 作为过渡，否则默认为下一行和上一行是同一级别的引用。 引用标记里可以使用其他标记，如：有序列表或无序列表标记，代码标记等。 代码块 如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，如果引用的语句只有一段，不分行，可以用 ` 将语句包起来。如果引用的语句为多行，可以使用 ``` 将这段代码包围起来。 语法 ``` public static void main(String[] args) { System.out.println(“Hello World”); } ``` `System.out.println(“Hello World”);` 显示效果 123public static void main(String[] args) &#123; System.out.println(\"Hello World\");&#125; System.out.println(&quot;Hello World&quot;); 注意事项 ` 这个符号是在 Esc 键下面，切换到英文下即可。 ``` 后面的 java 表示此段代码为 Java 代码，Markdown 会自行使用 Java 代码颜色渲染。这里也可以不写。 图片 在 Markdown 中，插入图片不需要其他按钮，你只需要使用 ![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 这样的语法即可，其中： Alt text 为如果图片无法显示时显示的文字； /path/to/img.jpg 为图片所在路径； Optional title 为显示标题。显示效果为在你将鼠标放到图片上后，会显示一个小框提示，提示的内容就是 Optional title 里的内容。 语法 1![5fdcde3dc7a0235d87005df1b0bf9272.jpg](https://i.loli.net/2019/02/15/5c66de03b76db.jpg) 显示效果 注意事项 导入的图片路径可以使用绝对路径也可以使用相对路径，建议使用相对路径。 我通常的做法是 Markdown 文档的同级目录下建立一个 images 文件夹，里面放置所有所需的图片，如果图片多的话，你也可以在 images 文件夹里建立子文件夹归类。 列表 熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 或 + 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3.，符号要和文字之间加上一个字符的空格。 语法 无序列表 123456* 呵呵 * 嘉嘉 * 嘻嘻 * 吼吼 * 嘎嘎 * 桀桀 有序列表 1231. 第一点2. 第二点3. 第三点 显示效果 无序列表 呵呵 嘉嘉 嘻嘻 吼吼 嘎嘎 桀桀 有序列表 第一点 第二点 第三点 注意事项 无序列表或有序列表标记和后面的文字之间要有一个空格隔开。 有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例所示。 无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如示例所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。 分割线 使用 --- 或者 *** 或者 * * * 表示水平分割线。 语法 123---**** * * 显示效果 注意事项 只要 * 或者 - 大于等于三个就可组成一条平行线。 使用 --- 作为水平分割线时，要在它的前后都空一行，防止 --- 被当成标题标记的表示方式。 链接 在 Markdown 中，插入链接不需要其他按钮，你只需要使用 [](link &quot;Optional title&quot;) 这样的语法即可，其中： [] 内的内容为要添加链接的文字。 link 为链接地址。 Optional title 为显示标题。显示效果为在你将鼠标放到链接上后，会显示一个小框提示，提示的内容就是 Optional title 里的内容。 语法 1[Baidu](www.baidu.com &quot;百度一下，你就知道&quot; ) 显示效果 Baidu 反斜杠 使用 \\ 表示反斜杠。在你不想显示 Markdown 标记时可以使用反斜杠。 语法 1\\*这里不会显示斜体\\* 显示效果 *这里不会显示斜体* 空格 Markdown 语法会忽略段落中的空格，如果要体现出空格的效果，可以使用 全角符号下的空格 或者使用转义字符 &amp;nbsp;。 删除线 使用 ~~ 表示删除线。 语法 1~~这是一条删除线~~ 显示效果 这是一条删除线 注意事项 注意 ~~ 和 要添加删除线的文字之间不能有空格。 我常使用在显示的告诉自己这行文字是要删除的。 结语 以上就是我在学习 Markdown 后的总结，其中介绍的 Markdown 语法都是基础并且比较常用的，我也对这些语法做出了比较详细的说明。如果有描述的不对的地方，欢迎批评指正，希望能对各位学习 Markdown 有所帮助。","categories":[{"name":"工具","slug":"工具","permalink":"http://blog.luckylight6.com/categories/工具/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://blog.luckylight6.com/tags/Markdown/"}]}]}